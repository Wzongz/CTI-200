{
    "event_id": "020",
    "claim": "The analysis reveals a targeted and stealthy backdoor implant with a specific set of functions designed to give attackers a strong foothold within an infected system. The malware uses a variety of techniques to avoid detection and maintain communication with the attacker's infrastructure.",
    "original_label": "true",
    "label": "true",
    "explain": "Analysis reveals the implant is a multi-threaded DLL backdoor that gives the threat actor (TA) full access to, and control of, the target host. When commanded by C2, the implant can upload or download files, create processes, interact with the host via a command shell and connect to C2 according to a defined sleep/activity schedule.As covered in Part 1, the implant is written in C++ and statically linked against OpenSSL and the Poco C++ framework. Since the file is packaged as a DLL, the intention would be to inject it into a long-running process that is granted Internet access (such as a NetSvc service group) or one having local firewall permissions. We do not believe this DLL is intended to operate as a module for a larger tool.Malicious code entry occurs via the DllMain export. The implant’s first task is to load the legitimate Microsoft npmproxy.dll found in “c:\\windows\\system32”. With this loaded, the addresses of the five implant exports, “DllCanUnloadNow”, “DllGetClassObject”, “DllRegisterServer”, “DllUnregisterServer” and “GetProxyDllInfo” are set to the addresses of the same, benign exports found in the Microsoft DLL.The reason for this is unconfirmed, but most likely serves a defensive measure to evade end point protection that scans export addresses looking for code changes (when compared to a predetermined signature database), or against a database of known-malicious code. Perhaps by setting its own exports to those of the benign copy, the implant is attempting to remain undetected:With export addresses replaced, a thread is launched to execute the main code path. Within this, a second thread is launched responsible for send and receive operations with C2. A global variable forms the basis of inter-thread synchronization for processing of C2 messages.The primary thread’s first task is the creation of a Globally Unique ID (GUID) mutex “1b8232f6-6806-4733-901d-62bf3ef33e6c”. The GUID string can be found as plain text within the binary, offering a potential (albeit trivially replaceable) IoC. As is customary, if mutex creation fails the sample terminates with no further action taken.Following mutex creation, the implant generates a unique CRC-32 host fingerprint using the primary network interface’s ethernet (MAC) address, the host name, and Windows version string. The final CRC-32 result is then XOR’d with fixed constant 0x64113. The generated host fingerprint is used later to build the C2 beacon URL, and presumably identifies the implant’s malicious use on each infected machine.The main communication protocol with the C2 server is RSA encrypted, Base64 encoded JSON exchanged over HTTPS (TLS, port 443), or as fallback, on plain HTTP using port 80. During our analysis the implant did not attempt to use any other application protocols.The user-agent string for HTTP requests is populated from either the return value of the “﻿ObtainUserAgentString” API call, or if that fails, a hard-coded alternate (see IoCs below).Support for egress proxy servers is included through a call to“﻿WinHttpGetIEProxyConfigForCurrentUser”. The result is parsed and supplied to the Poco framework’s “﻿ HTTPClientSession::setProxyConfig” prior to C2 activity.A 1024-bit RSA key pair is embedded within the implant and used to encrypt and decrypt communication between host and C2. The private key decrypts inbound traffic while the public key encrypts outbound. No stream cipher(s) or session keys are negotiated.The initial HTTPS beacon to “malaytravelgroup[.]com” is a GET request consisting of a randomly selected URL path concatenation, together with a query string containing the parameter split count, the XOR constant 0x64113 (also used when generating the host CRC-32), and the computed CRC-32 fingerprint. The query string is padded with random data to prevent ad-hoc analysis and finally Base64 encoded:The URL path component is built as one to three strings (“/” separated), generated from a set of encrypted string tables. The decrypted versions are provided in the Appendix.The Base64 encoded data is split into a random number of parameters and padded as a means of obfuscation. The query parameter’s names are randomly generated using 1-4 upper/lower case characters:Using the first example in Figure 3, the first query parameter indicating the beacon data split count would be Base64 decoded as:All successive query parameters have the first two characters removed prior to Base64 decoding. The first byte of the decoded result is then discarded to arrive at the final value:Once the beacon is received and decoded, the next phase of interaction is to issue commands that drive the implant’s functions, such as the provision of an activity schedule/sleep interval limiting implant activity.The primary C2 domain of “malaytravelgroup[.]com” is used for the initial beacon. Like all sensitive strings, it is XOR encoded and revealed only when needed.The implant also contains a Linear Congruential Generator (LCG) based algorithm for generating what appear to be backup C2 domain names. Curiously the implementation is 100% deterministic owing to the use of a fixed seed value (0xC31) as shown in Figure 4. Every invocation of the DGA will produce the same five domains: Domain names are generated as the concatenation of 4 string-table lookups from 3 encrypted string tables. Table 3 is referenced twice during generation. The Top-Level Domain (TLD) suffix is hardcoded to “.com”.Assuming the continued adoption of a four-part domain name, the LCG would be capable of generating millions of unique permutations. The reason for limiting its output to the same five, irrespective of date, time, host identity, or other input variable is unclear. A copy of the decrypted string tables is provided in the Appendix.By manually decreasing the delay between check-in attempts, we accelerated the amount of C2 activity generated by the implant. Curiously, during a 24-hour observation window, no attempts were made to communicate with the generated domains. Different reachability scenarios were tested, ranging from malformed responses to unreachable IP addresses. At no point did the implant generate any DNS or HTTP traffic relating to the generated domains.It’s conceivable the backup domains are accessed via HTTP 302 redirects issued by the primary site, but this would seemingly defeat the purpose of having primary and backup domains to cater for failure, migration, or shutdown. It’s also possible the generated C2 domains are active only for certain implant commands such as file upload or download.Lacking any evidence for their direct use, we can speculate the generated domains may be operating as a honeypot. Access to them from any Internet addresses would immediately be considered “suspicious” by virtue of their hidden existence only within the implant code. The source of such requests could be directly attributable to threat researchers or analysts investigating the implant’s inner workings.The implant lacks any modularity and is therefore limited to eight functions. Each function is invoked from C2 by supplying a value from which a known CRC-32 is calculated. The computed CRC-32 value serves as a key or look-up to execute the corresponding function.The shell capability is perhaps the most interesting, giving the operators a full-duplex, interactive COMSPEC (cmd.exe) session, with stdin (input), stdout, and stderr (output returned by commands) redirected over the HTTPS C2 channel. Commands to the shell are issued by the TA with the resulting output being returned almost immediately.Despite the shell pipe creation taking place in (as identified by IDA signatures) the Poco framework’s “SMTPChannel” constructor, the implant makes no use of SMTP as a transport. The “bash” parameter, synonymous with Linux environments, hints at a multi-platform capability. However, in this instance it is used to send commands to the shell by writing the accompanying value to stdin. Windows 10 does offer a Linux Subsystem that would make a bash shell available, but we have no evidence to suggest this is what the operators are installing or using:Thirteen unique XOR keys are used throughout the implant for runtime decoding of sensitive strings. Each implant function (as listed in Table 4) is provided with its own XOR key, as are general C2, URL/HTTP, and RSA related operations:Analysis shows the implant carries a feature set designed to provide the fundamental capabilities of a backdoor: file download, upload, remote command execution, and interactive shell access.Comparing the functions of this implant to published descriptions of APT-28’s “x-tunnel”, we find no tunneling, proxying, or VPN-like capabilities. It also lacks credential harvesting, network service scanning, or Windows registry manipulation. Given the lack of modularity only an updated version could provide these features. The alternative (and perhaps more likely) scenario would be for such capabilities to exist in subsequent tools downloaded and executed by this implant.\n\n\n",
    "reports": [
        {
            "link": "https://www.securityartwork.es/2019/04/04/ukraine-election-2019-polls-maldoc-analysis/",
            "content":   "All the context and sophistication of the content of the document makes it to stand out from the generic campaigns of malware infections, fitting more into TTPs related to APT groups. During its execution, the Powershell process constantly checks the “functiondiscovery[.]net” domain through port 8443 using the HTTPS protocol Looking for the hash of the document in Virustotal, we see the following comment, which suggests that it may be a dropper of the group APT28 or Hades. In that case, the threat that was embedded was a dll and much more clearly attributed to this group:. Once extracted, we see the function responsible for the execution of the threat:This function executes the next stages by extracting text in Base64 from the “Company” field of the document metadata, decoding it and launching a “cmd.exe” with WMI.By executing the next payload through WMI, the process created does not depend on the Microsoft Winword editor but “WmiPrvSE.exe”:The decrypted base64 text consists of a obfuscated Bash command that after several calls to CMD.exe, ends up loading a Powershell.exe with the final Payload. Regarding its malicious logic, it depends on macros, which are protected with a password in order to make its analysis more difficult:This is not a serious problem, since there are many tools that allows to extract them despite that. The truth is that in addition to the pattern of infection and the subject of the document (already exploited earlier by this group in their malicious documents), within the macros of this document we see that the names of functions and their use of WMI coincide with another recent document with hash “8cccdce85beca7b7dc805a7f048fcd1bc8f7614dd7e13c2986a9fa5dfbbbbdf9“, which the researcher @VK_intel suggests may be part of the APT28 toolset.",
            "domain": "securelist.com",
            "tokenized": [
                {
                    "sent":   "All the context and sophistication of the content of the document makes it to stand out from the generic campaigns of malware infections, fitting more into TTPs related to APT groups.",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent":  "During its execution, the Powershell process constantly checks the “functiondiscovery[.]net” domain through port 8443 using the HTTPS protocol Looking for the hash of the document in Virustotal, we see the following comment, which suggests that it may be a dropper of the group APT28 or Hades.",
                    "is_evidence": 0
                },
                {
                    "sent":  "In that case, the threat that was embedded was a dll and much more clearly attributed to this group:",
                    "is_evidence": 0
                },
                {
                    "sent":  "Once extracted, we see the function responsible for the execution of the threat:This function executes the next stages by extracting text in Base64 from the “Company” field of the document metadata, decoding it and launching a “cmd.exe” with WMI.By executing the next payload through WMI, the process created does not depend on the Microsoft Winword editor but “WmiPrvSE.exe”:The decrypted base64 text consists of a obfuscated Bash command that after several calls to CMD.exe, ends up loading a Powershell.exe with the final Payload.",
                    "is_evidence": 0
                },
                {
                    "sent":  "Regarding its malicious logic, it depends on macros, which are protected with a password in order to make its analysis more difficult:This is not a serious problem, since there are many tools that allows to extract them despite that.",
                    "is_evidence": 0
                },
                {
                    "sent":    "The truth is that in addition to the pattern of infection and the subject of the document (already exploited earlier by this group in their malicious documents), within the macros of this document we see that the names of functions and their use of WMI coincide with another recent document with hash “8cccdce85beca7b7dc805a7f048fcd1bc8f7614dd7e13c2986a9fa5dfbbbbdf9“, which the researcher @VK_intel suggests may be part of the APT28 toolset.",
                     "is_evidence": 0
                }
            ]
        },
        {
            "link": "https://www.welivesecurity.com/2018/11/20/sednit-whats-going-zebrocy/",
            "content": "During the investigation, Doctor Web specialists analyzed and described several groups of trojan programs, including new samples of trojan families already encountered by our virus analysts, as well as previously unknown trojans. In both cases, the attackers used a similar selection of malware, including the same specialized backdoors that infected domain controllers in the attacked organizations. It is a multi-module backdoor written in C/C++ and Assembler and designed to run on 32-bit and 64-bit Microsoft Windows operating systems. The analysis showed that certain PlugX modifications used the same domain names of C&C servers, as did other backdoors related to targeted attacks on Central Asian state institutions. The backdoor’s DLL library is loaded into RAM by DLL Hijacking using the genuine executable file TosBtKbd.exe from TOSHIBA CORPORATION. Various modifications of this malware family are a well-known tool of the Winnti APT group, presumably of Chinese origin, active since at least 2012.",
            "domain": "www.welivesecurity.com",
            "tokenized": [
                {
                    "sent":  "For the first execution of the malware, it creates the file set.txt with {System_Parametrs = 10} inside and creates the Windows registry entry:One screenshot of the victim’s computer is taken under the name scx.bin and sent as an email attachment with SC (which probably stands for Screenshot) in the email’s body.",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent":  "Notice that the executable payload’s",
                    "is_evidence": 0
                },
                {
                    "sent":  "Perhaps this is an attempt to avoid endpoint protection systems triggering an alert based on a binary dropping a file with a .exe extension.",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent":     "The operator tries to fool the victim by naming the executable with an apparent document or image file name by incorporating the “double extension” trick..",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent":    "While this downloader has some backdoor features, it drops a Delphi downloader already associated with the group, and described in our previous Zebrocy article.",
                    "is_evidence": 1,
                    "is_repeat": 0
                }
            ]
        },
        {
            "link": "https://www.welivesecurity.com/2017/05/09/sednit-adds-two-zero-day-exploits-using-trumps-attack-syria-decoy/",
            "content":  "Finally, the window procedure running with elevated privileges will steal the SYSTEM token and add it to the calling process. The LoadLib is a bit field that allows running an arbitrary DLL by calling rundll32.exe CVE-2017-0263 - Local privilege escalation Exploit Workflow As mentioned before, in order to deploy Seduploader Payload, Seduploader Dropper gains System privileges by exploiting CVE-2017-0263, an LPE vulnerability. The graphic below shows that this specific attack is totally in line with Sednit’s usual attack methods: the use of a spearphishing email containing a malicious attachment to install a known first-stage payload. Then, the exploit associates this procedure with the newly allocated object, KernelWnd. This code will run with System privileges, thanks to the exploit.",
            "domain": "quointelligence.eu",
            "tokenized": [
                {
                    "sent": "Finally, the window procedure running with elevated privileges will steal the SYSTEM token and add it to the calling process.",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent": "The LoadLib is a bit field that allows running an arbitrary DLL by calling rundll32.exe CVE-2017-0263 - Local privilege escalation Exploit Workflow As mentioned before, in order to deploy Seduploader Payload, Seduploader Dropper gains System privileges by exploiting CVE-2017-0263, an LPE vulnerability.",
                    "is_evidence": 0
                },
                {
                    "sent": "The graphic below shows that this specific attack is totally in line with Sednit’s usual attack methods: the use of a spearphishing email containing a malicious attachment to install a known first-stage payload.",
                    "is_evidence": 0
                },
                {
                    "sent":  "Then, the exploit associates this procedure with the newly allocated object, KernelWnd.",
                    "is_evidence": 0
                },
                {
                    "sent":  "Then, the exploit calls NtUserMNDragLeave, in order to flip the bServerSideProc bit of our KernelWnd object.",
                    "is_evidence": 0
                },
                {
                    "sent":  "This code will run with System privileges, thanks to the exploit.",
                    "is_evidence": 0
                }
            ]
         },
         {
            "link": "https://unit42.paloaltonetworks.com/unit42-sofacy-continues-global-attacks-wheels-new-cannon-trojan/",
            "content":  "Indicators of Compromise The Cannon Trojan is written in C# and functions primarily as a downloader that relies on emails to communicate between the Trojan and the C2 server. Like other Zebrocy samples, this Trojan collects system specific information it will send to the C2 server by running the command SYSTEMINFO & TASKLIST on the command line and by enumerating information about connected storage devices. Specific to this technique, if the C2 server is not available at the time of execution, the malicious code cannot be retrieved, rendering the delivery document largely benign. The C2 server will then provide a secondary payload to the beacon in ASCII hexadecimal representation, which the Trojan will decode and write to the following location: During our analysis, the C2 server provided a secondary payload that functionally appeared similar to the initial Zebrocy sample. The tool is written in C# whose malicious code exists in a namespace called cannon, which is the basis of the Trojan’s name. Traps blocks the macro-ladened remote templates as Suspicious macro detected, as well as Zebrocy and Cannon payloads as Suspicious executable detected.",
            "domain": "unit42.paloaltonetworks.com",
            "tokenized": [
                {
                    "sent":  "Indicators of Compromise The Cannon Trojan is written in C# and functions primarily as a downloader that relies on emails to communicate between the Trojan and the C2 server.",
                    "is_evidence": 1,
                    "is_repeat": 0
                },
                {
                    "sent":  "Like other Zebrocy samples, this Trojan collects system specific information it will send to the C2 server by running the command SYSTEMINFO & TASKLIST on the command line and by enumerating information about connected storage devices.",
                    "is_evidence": 0
                },
                {
                    "sent":  "Specific to this technique, if the C2 server is not available at the time of execution, the malicious code cannot be retrieved, rendering the delivery document largely benign.",
                    "is_evidence": 0
                },
                {
                    "sent": "The C2 server will then provide a secondary payload to the beacon in ASCII hexadecimal representation, which the Trojan will decode and write to the following location: During our analysis, the C2 server provided a secondary payload that functionally appeared similar to the initial Zebrocy sample.",
                    "is_evidence": 0
                },
                {
                    "sent":  "The tool is written in C# whose malicious code exists in a namespace called cannon, which is the basis of the Trojan’s name.",
                    "is_evidence": 0
                },
                {
                    "sent":  "Traps blocks the macro-ladened remote templates as Suspicious macro detected, as well as Zebrocy and Cannon payloads as Suspicious executable detected.",
                    "is_evidence": 0
                }
            ]
        }
    ]
}