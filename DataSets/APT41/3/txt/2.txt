In July 2020, we released a study of targeted attacks on state institutions in Kazakhstan and Kyrgyzstan with a detailed analysis of malware found in compromised networks. During the investigation, Doctor Web specialists analyzed and described several groups of trojan programs, including new samples of trojan families already encountered by our virus analysts, as well as previously unknown trojans. The most notable discovery was the samples of the XPath family. We were also able to find evidence that allowed us to link two initially independent incidents. In both cases, the attackers used a similar selection of malware, including the same specialized backdoors that infected domain controllers in the attacked organizations. During the examination, analysts studied samples of PlugX multi-module backdoors used for initial penetration into the network infrastructure. The analysis showed that certain PlugX modifications used the same domain names of C&C servers, as did other backdoors related to targeted attacks on Central Asian state institutions. The detection of the PlugX programs indicates Chinese APT groups are possibly involved in these incidents. According to our data, the unauthorized presence in both networks lasted for more than three years, and several hacker groups could be behind the attacks. Investigations of such complex cyber incidents involve long-term work, so they are rarely covered by a single article. The Doctor Web virus laboratory received new samples of malware found on the infected computers in the local network of a state institution in Kyrgyzstan. In addition to the malware described in the previous article, the ShadowPad backdoor deserves particular attention. Various modifications of this malware family are a well-known tool of the Winnti APT group, presumably of Chinese origin, active since at least 2012. It is noteworthy that the Farfli backdoor was also installed on computer along with ShadowPad, and both programs referred to the same C&C server. Additionally, we uncovered several PlugX modifications on the same computer. In this study we analyzed the algorithms of the detected backdoors. Special attention is paid to the code similarities between the ShadowPad and PlugX samples, as well as to some intersections in their network infrastructure. For further research, we found and analyzed other samples of the ShadowPad family in order to perform a detailed examination of the similarities between the ShadowPad and PlugX backdoors:For further research, we found and analyzed other samples of the ShadowPad family in order to perform a detailed examination of the similarities between the ShadowPad and PlugX backdoors: The available data allow us to conclude that these families are related in terms of simple code borrowing or the development of both programs by one author or a group of authors. In the second case, it is very likely that ShadowPad is an evolution of PlugX as a newer and more advanced APT tool. The storage format of the malicious modules used in the ShadowPad makes it much more difficult to detect them in RAM. The available data allow us to conclude that these families are related in terms of simple code borrowing or the development of both programs by one author or a group of authors. In the second case, it is very likely that ShadowPad is an evolution of PlugX as a newer and more advanced APT tool. The storage format of the malicious modules used in the ShadowPad makes it much more difficult to detect them in RAM. The backdoor’s DLL library is loaded into RAM by DLL Hijacking using the genuine executable file TosBtKbd.exe from TOSHIBA CORPORATION. On the infected computer, the file was named msmsgs.exe. The module name specified in the export table is TosBtKbd.dll. The DLLMain function and the UnHookTosBtKbd export function are stubs. The SetTosBtKbdHook function performs an exhaustive search through the handles in order to find objects whose names contain TosBtKbd.exe and then closes them. The ECX register initially contains the address of the allocated executable buffer. The backdoor then loads the module sections according to their RVA (Relative Virtual Address). Section data is stored in the shellcode after the header, and the offset to the (section.raw_data_offset) data is counted from the beginning of the header. After the sections, the program processes relocations that are stored as IMAGE_BASE_RELOCATION structures, but each WORD, which is responsible for the relocation type and for the offset from the beginning of the block, is encrypted. The initial key is taken from module_header.key, and it changes after each iteration. It is worth noting that the key obtained after all iterations will be used for processing import functions. Relocations processing algorithm: Next, BackDoor.ShadowPad.1 starts processing the import functions. In general, the procedure is standard, but the names of libraries and functions are encrypted. The key that was modified after processing the relocations is used, and is also changed after each encryption iteration. After processing the next import function, its address is not placed directly in the cell specified relative to IMAGE_IMPORT_DESCRIPTOR.FirstThunk. Instead, a block of instructions is generated that passes control to the API: It is worth noting that the code snippets contained in this module, as well as some objects, are typical of the BackDoor.PlugX family. When called with the code 1, the module proceeds to perform the main functions. At first, the program registers a top-level exception handler. When receiving control, the handler generates a debug string with information about the exception. After decrypting the header, the backdoor checks the value of flags. If the 0x8000 flag is set, it means that the module consists of only one header. Then the first byte’s zero bit value is checked in the decrypted block. If the zero bit has the value 1, it means the module body is compressed by the QuickLZ algorithm. After unpacking, the malware checks the size of the resulting data with the values in the header and proceeds directly to loading the module. To do so, it allocates an executable memory buffer to which it copies the load function and then passes control to it. Each module has the same format as the Root module, so it has its own header and encrypted import functions and relocations; therefore, loading occurs in the same way. After the module is loaded, the loader function calls its entry point with the code 1. Each module, like Root, initializes its function table using this code. Then Root calls the entry point of the loaded module sequentially with the codes 0x64, 0x66, and 0x68. This way, the backdoor initializes the module and passes it pointers to the necessary objects. Modules are represented as objects combined in a linked list. Referring to a specific module is performed using the code the plug-in puts in its object after calling its entry point with the code 0x66. If one converts the timestamp fields from the headers of each plugin to dates, one gets the correct date and time values: After loading all the Root modules, the malware searches the list for the Install module and calls the second of the two functions located in its function table.First of all, the backdoor gets the SeTcbPrivilege and SeDebugPrivilege privileges. Then it obtains the configuration using the Config module. To access functions, the adapter functions of the following type are used: Through the object that stores the list of loaded modules, the backdoor finds the necessary one using the code, then the necessary function is called through the table. During the first step of the configuration initialization, the buffer stored in the Root module is checked. If the first four bytes of this buffer are X, this means the backdoor needs to create a default configuration. Otherwise, this buffer is an encoded configuration. The configuration is stored in the same format as plug-ins—it is compressed using the QuickLZ algorithm and encrypted using the same algorithm used for plug-in encryption. 0x858 bytes are reserved for the decrypted and unpacked configuration. Its structure can be represented as follows: Fields named off_* contain offsets to encrypted strings from the beginning of the configuration. The strings are encrypted with the same algorithm as used to encrypt the names of the plug-ins. After initialization, the backdoor also attempts to get the configuration from the file located in the %ALLUSERSPROFILE%\\\\ directory. The path and file name elements are generated during execution and depend on the serial number of the system partition. After initializing the configuration, the mode parameter is checked, which is stored in the shellarg structure. That structure is filled in by the loader (shellcode) and stored in the stage_1 module.The algorithm provides a number of possible values for the mode parameter—2, 3, 4, 5, 6, 7. If the value is different from the listed ones, the backdoor is installed in the system, and then the main functions are performed. A series of values 2, 3 ,4—to begin interaction with the C&C server, bypassing the installation. A series of values 5, 6—to work with the plug-in with the code 0x6A stored in the registry. Value 7—using the IFileOperation interface, the source module is copied to %TEMP%, as well as to System32 or SysWOW64, depending on the system bitness. This is necessary to restart the backdoor with UAC bypass using the wusa.exe file.During installation, the backdoor checks the current path of the executable file by comparing it with the value of off_bin_path from the configuration (%ALLUSERSPROFILE% \Messenger\msmsgs.exe). If the path does not match and the backdoor is launched for the first time, a mutex is created, the name of which is generated as follows: Format of the mutex name for wsprintfW is Global\%d%d%d. Then checks whether UAC is enabled. If control is disabled, the malware creates the control.exe process (from System32 or SysWOW64, depending on the system's bitness) with the CREATE_SUSPENDED flag. After that, the backdoor injects the Root module into it, using WriteProcessMemory. Before doing this, the backdoor also implements a function that loads the module and transfers control to it. If UAC is enabled, this step is skipped. The main executable file (msmsgs.exe) and TosBtKbd.dll are copied to the directory specified in the off_bin_path parameter and then installed as a service. The service name, display name, and description are contained in the configuration (parameters off_svc_name, off_svc_display_name, and off_svc_description). In this sample all three parameters have the Messenger value. If the service fails to start, the backdoor is registered in the registry. The key and parameter name for this case are also stored in the configuration (off_reg_key_install and off_reg_value_name parameters). After installation, the backdoor attempts to inject the Root module into one of the processes specified in the configuration (off_inject_target_<1..4>). If successful, the current process terminates, and the new process (or service) proceeds to interact with the C&C server. A separate thread is created for this purpose. After that, a new registry key is created or an existing registry key is opened, which is used as the malware's virtual file system. The key is located in the Software\Microsoft\ branch, and the value is also generated depending on the serial number of the system volume. The key can also be located in the HKLM and HKCU, depending on the privileges of the process. Next, the RegNotifyChangeKey function tracks changes in this key. Each parameter is a compressed and encrypted plug-in. The backdoor extracts each value and loads it as a module, adding it to the list of available ones.This functionality is executed in a separate thread. The next step generates a pseudo-random sequence from 3 to 9 bytes long, which is written to the registry in the SOFTWARE\ key located in the HKLM or HKCU. The parameter name is also generated and is unique for each computer. This value is used as the ID of the infected device. After that, the backdoor extracts the address of the first C&C server from the configuration. The server storage format is as follows: ://
:. In addition to the values that explicitly define the protocol used (HTTP, TCP, UDP), the URL value can also be specified. In this case, the backdoor refers to this URL and receives a new address of the C&C server in response, using the domain generation algorithm (DGA). The algorithm generates the string: When using the HTTP protocol, data is sent by a POST request:Data transfer over HTTP is performed by the handler function in a separate thread. The mechanism is similar to that of BackDoor.PlugX. DNS servers from the configuration are used to resolve the addresses of C&C servers (in this sample all 4 addresses are 8.8.8.8). The first packet sent to the server is a sequence of zeros from 0 to 0x3f bytes in length. The length is selected randomly. The backdoor receives a response from the server, which is then decrypted and unpacked. Then, the packet header checks the module_code value, which contains the code of the plug-in for which the command was received. The backdoor refers to the plug-in whose code is specified in the command and calls the function for processing commands from its table. The ID of the command itself is contained in the id field of the header.Command IDs for the Plugins module can have the following values id—0x650000, 0x650001, 0x650002, 0x650003, or 0x650004. In fact, the Plugins module is a plug-in manager, allowing one to register new plug-ins and delete existing ones.In the historical WHOIS record of the С&С server domain, one can observe the Registrar's email address: ddggcc@189[.]cn. The same address is found in the icefirebest[.]com and www[.]arestc[.]net domain records, which were contained in the configurations of PlugX backdoor samples installed on the same computer. It is a multi-module backdoor written in C/C++ and Assembler and designed to run on 32-bit and 64-bit Microsoft Windows operating systems. It is used in targeted attacks on information systems for gaining unauthorized access to data and transferring it to C&C servers. Its key feature is utilizing plug-ins that contain the main backdoor’s functionality. It is a malicious DLL whose original name—hpqhvsei.dll—is found in the export table. Like BackDoor.ShadowPad.1, this modification has a lot in common with the malware samples of the BackDoor.PlugX family. Export functions are absent. The timestamp from the export table is identical to that from the PE header. The algorithm for loading additional modules is also similar to BackDoor.ShadowPad.1; however, there are new modules in this sample. The backdoor has 16 modules in total. A list of their names with codes and timestamps is provided in the following table: For each loadable module a structure is formed that is added to the list that modules can use to call each other's functions. To work with this list and for other auxiliary tasks, the Root module exports the function table. During initialization of the Plugins module, a top-level exception handler is registered. In BackDoor.ShadowPad.1 this handler generated a string with information about the exception for debugging purposes. However, in BackDoor.ShadowPad.3 it only terminates the thread that caused the exception. In this case, the mechanism is similar to BackDoor.PlugX.28. The key difference between the functions in this case is that PlugX operates on an object containing a linked list of all running threads, while ShadowPad directly terminates the current thread. However, in general, there is an analogue with the ShadowPad object, which stores loaded modules as a list. The main payload execution starts with the Install module. Similar to BackDoor.ShadowPad.1, at the beginning of this stage, the backdoor obtains the necessary privileges. It is worth noting that the first stages of operation are similar to those of the PlugX backdoors we studied earlier. The illustrations below show a comparison between the BackDoor.ShadowPad.3 and BackDoor.PlugX.38 algorithms.Then the malware initializes the configuration using the Config module. There is also a similarity with BackDoor.PlugX at this stage. At the beginning, the backdoor checks the first four bytes of the buffer where the encrypted configuration should be stored. If the bytes are 0x58585858 (XXXX" in ASCII), then:The illustrations below show a comparison between the BackDoor.ShadowPad.3 and BackDoor.PlugX.28 algorithms. After initializing the configuration, the backdoor checks the value of mode in the shellarg structure passed from the module loader. Actions in accordance with the value of mode are similar to those of BackDoor.ShadowPad.1. With the mode 5 or mode 6 values, the backdoor searches the list for a module with the code 0x6A (ImpUser) and calls a function from its table. In the BackDoor.ShadowPad.1 the ImpUser module was missing. This module is used for injecting into a process that is created either with the environment of the current session, or by a remotely connected user. In the context of this process, further commands from the C&C server will be processed, which must be received through a pipe from another running instance of the backdoor. Thus, the backdoor running with mode 5 or mode 6 acts as a “server” for the pipe connection, and its second instance relays commands to it from the C&C server. Below is a list of processes that the backdoor attempts to inject a payload into:Similar functionality exists in the PlugX family of backdoors. For example, in BackDoor.PlugX.38 the named thread DoImpUserProc is responsible for this. If the values are mode 7 or mode 8, the backdoor attempts to perform a UAC Bypass using the DLL hijack of dpx.dll library, loaded by the wusa.exe process (it has the autoElevate property), and the IFileOperation COM interface. To do this, it extracts its copy—dpx.dll (1d4a2acc73a7c6c83a2625efa8cc04d1f312325c), which attempts to run the original copy of the backdoor with elevated privileges. The patterns of BackDoor.ShadowPad.3, depending on the value of the shellarg.mode parameter, are similar to the behavior of PlugX. In the shellarg structure of the BackDoor.PlugX.28 there is a op_mode parameter, which determines the work patterns of the malware (installation in the system, injection, function interception, etc.). BackDoor.ShadowPad.3, similar to BackDoor.ShadowPad.1, can achieve persistence either as a service or by using the autorun key. The service name, its description, display name, and registry parameter name are stored in the configuration. Like the PlugX family, BackDoor.ShadowPad.3 uses mutexes with names that depend on the process ID to synchronize the restarted program process and the parent process. This backdoor also uses a mutex to prevent restarts. The name for the mutex is generated by a special function of the Config module.The same function is also used to generate the name of the file that stores the configuration, the directory where screen screenshots are stored, and so on. The result of generation depends on the seed transferred to the function and the serial number of the system volume. A similar approach to generating unique names was used in BackDoor.PlugX.28: Before connecting to the C&C server, the backdoor uses a function to generate a string with the 0x434944 seed (CID in ASCII). This string is used as a key name and registry parameter to store the ID of the infected computer. The ID itself is an array of 8 random bytes. Thus, the backdoor attempts to save the following structure in the registry at \Software\\ (it is also possible to save it in the HKLM or HKCU sections): It should be noted that the previously analyzed PlugX samples also generate a computer ID before starting a dialog with the server and save it in the registry. A certain seed is used for generation. After creating the ID, the backdoor performs a network scan and starts interacting with the C&C server. Network scanning is necessary to search for other infected systems on the local network. To do this, 4 separate threads are started:Scanning sends a TCP packet containing the unique identifier of the infected computer. The response is a similar packet. If the IDs do not match, the IP address from which the packet is received becomes the address of the C&C server for the backdoor. For local communication, the port used is the one hardcoded in the configuration in the config.port_to_scan parameter. There are 2 scanning modes available:To work in server mode the backdoor opens a port from the configuration and waits for an incoming connection from clients. When a new connection is received, a tunnel is created between the local client and the actual C&C server. Network communication in scanning and tunneling mode is performed using the TCP module. The format and structure of the packet are similar to BackDoor.ShadowPad.1. The functionality of the backdoor in server mode in the local network is also present in the PlugX samples. In particular, in BackDoor.PlugX.38 the JoProc named threads are used for this purpose:After initializing the local tunnel, BackDoor.ShadowPad.3 starts to establish the connection to the C&C server. At the first stage, the backdoor attempts to connect directly to the server specified in the configuration as a string. If the attempt fails, it retrieves the proxy server settings from the configuration and attempts to connect to the server using the proxy. After a successful connection, it sends a packet with 0 to 31 random bytes written in the body. The response is a command for a plug-in. The commands for Plugins, Config, Install, and Online are identical to the BackDoor.ShadowPad.1 commands with some exceptions: The module is designed to work with recent files and has one command—0x13D0000. When the command is received, the backdoor lists all files with the .lnk extension in %USERPROFILE %\AppData\Roaming\Microsoft\Windows\Recent and retrieves information for each of them using the COM interfaces IShellLinkW and IPersistFile.The SetTosBt, SetTosBtKbd and SetTosBtKbdHook exports are valid and refer to the main malicious function of the trojan, while UnHook, UnHookTosBt and UnHookTosBtKbd represent the dummy exports.TosBtKbd.dll is loaded into the memory using the DLL hijacking technique through the TosBtKbd.exe application found inside the main dropper. Similar to the BackDoor.ShadowPad.1 trojan, upon launching, the library goes through the handles looking for an object with the TosBtKbd.exe name and tries to close it. Next, it decrypts the shellcode that loads the main malicious module, TosBtKbdLayer.dll, detected by Dr.Web Anti-Virus as a BackDoor.Siggen2.3243. The entry point of the loaded module is provided with two values of the code that is transferred from the loader:BackDoor.ShadowPad.4 verifies the current date. If it is 01.01.2021 or later, it stops its execution. The trojan copies files necessary for its work into the %ALLUSERSPROFILE%\DRM\Toshiba directory and tries to install itself as a service. If it fails, it registers itself to the autorun, modifying the [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run] registry key or [HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run] if the first attempt was unsuccessful. Next, BackDoor.ShadowPad.4 tries to perform an inject. To do so, the trojan creates a dllhost.exe process with the CREATE_SUSPENDED flag and tries to inject a shellcode, responsible for malicious module loading, into it. It also tries to inject the module itself, using the strVirtualAllocEx -> WriteProcessMemory -> CreateRemoteThread scheme. To create a process, the following command line is used:If the injection was successful, the current process is terminated. Otherwise, the trojan tries to perform the inject into the created process, using the current session token. When it runs in the context of a new process, BackDoor.ShadowPad.4 uses mutex to locate the parent process and terminates it. The name of the mutex is generated with the following function:Next, the trojan tries to inject its main module into the wmplayer.exe process created with the environment, obtained with the duplicate of the current session token. If it successful, it terminates the current process; if failed, it proceeds to its main functionality. When it runs in the context of wmplayer.exe, BackDoor.ShadowPad.4 proceeds to its main functionality immediately. Thus, it loads the TosBtKbdLayer.dll library into the memory and sends the ID of the infected computer to the С&C server.Using the LoadLibrary function, BackDoor.ShadowPad.4 loads the TosBtKbdLayer.dll library into the memory. It then generates the sequence of 16 random bytes that represents the ID of the infected computer. If it has administrator rights, the trojan saves this ID in the ID1 parameter of the [HKLM\SOFTWARE\WAD] registry key. If it doesn’t have the appropriate rights, it saves it in the parameter of the [HKCU\SOFTWARE\WAD] registry key. After that, BackDoor.ShadowPad.4 creates the UDP socket and binds to it, but doesn’t call the listen function for it to listen to the connection. After that, it generates the winhook\tdzkd\t\t string, where: A trojan library written in C++. It represents a dropper designed to deliver other malware to computers running 32-bit and 64-bit Microsoft Windows operating systems. The analyzed sample is used to load the main malicious module, hidden in the encrypted file, into the memory. The library loads to the memory by the RasTls.exe tool using the DLL-hijacking mechanism. Next, it decrypts the shellcode from the RasTls.dat file stored in its body and transfers control to it:In turn, this shellcode uses an XOR operation with the 0xCC byte to decrypt the main payload (Dr.Web detects it as BackDoor.Farfli.125) and loads it into the memory. After that, it changes the strings MZ and PE to BB and CC, respectively, in the signature header of an executable file. In turn, this shellcode uses an XOR operation with the 0xCC byte to decrypt the main payload (Dr.Web detects it as BackDoor.Farfli.125) and loads it into the memory. After that, it changes the strings MZ and PE to BB and CC, respectively, in the signature header of an executable file. The library is loaded into the memory by BackDoor.Farfli.122. It exports the mystart function that contains the main malicious functionality. This library has a PcMain.exe name in the exporting table. Upon receiving control from the shellcode loaded by BackDoor.Farfli.122, BackDoor.Farfli.125 performs various checkups. At the beginning, the trojan determines if it has been launched through the Wow64 subsystem and runs in the 64-bit environment. With that, if the IsWow64Process function execution returns an error, it displays a MessageBox with the x1 text. Next, BackDoor.Farfli.125 checks whenever the module file name has \explorer.exe or \internet explorer\iexplore.exe.exe name, where represents a result of the GetTickCount function execution in the %08x format. If the backdoor does not run in the context of the explorer.exe or IE process, it creates a C: \Microsoft\TEMP\Networks\Connections\Pbksn\nvdiassnx\ky3log.dat file. Upon completing the initial preparation, the trojan checks if it runs in the context of the explorer.exe or iexplore.exe process and if it was launched from the ...\nvdiassnx directory. If it runs in the context of the explorer.exe or iexplore.exe process, BackDoor.Farfli.125 immediately proceeds to its main malicious functionality. Otherwise, it verifies if it runs from the ...\nvdiassnx.If the trojan was not launched from the ...\\nvdiassnx directory, it checks if the Global\ \vssafuyuhdw332kjgtts1 event is present. If it exists, it terminates its process to ensure only one copy of the trojan is launched. Otherwise, the trojan moves its components— RasTls.exe, RasTls.dll and RasTls.dat—to the C: \Microsoft\TEMP\Networks\Connections\Pbksn\nvdiassnx directory. Its further actions depend on the operating system version. If BackDoor.Farfli.125 is running on Windows Vista and later Windows versions, the RasTls.exe module is set to autorun through the [HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] registry key. Next, the trojan launches the iexplore.exe process with the CREATE_SUSPENDED flag, reads the shellcode from the RasTls.dat file, decrypts and injects it into the iexplore.exe process, launched earlier, continuously using the VirtualAllocEx, WriteProcessMemory and ResumeThread functions. Herewith, it patches the entry point of the process so the injected shellcode will receive control. If BackDoor.Farfli.125 is running on a Windows version below Windows Vista and not through the Wow64 subsystem, the trojan performs the same actions but injects the shellcode into the explorer.exe process. If the trojan is launched from the ...\\nvdiassnx directory, it performs the same actions described earlier, excluding the Global\\vssafuyuhdw332kjgtts1 event check and moving files.BackDoor.Farfli.125 creates a Global\\vssafuyuhdw332kjgtts1 event and receives the addresses of the API functions it needs. To do so, it searches for the signature of two consecutive DWORD 0x8776633 and 0x18776655, starting from the trojan module base. This signature is located at the beginning of the last section of the module itself. With that, the section is nameless and contains various service strings, including the API functions names, as well as a compressed trojan configuration. The section contains three blocks of compressed data. The first block has the strings, the second block has the trojan configuration, and the third block remains empty. Herewith, the second and third blocks are located at the end of the section:After the necessary APIs are loaded, it finds the structure of the last section and unpacks the second block, which contains the configuration of the backdoor. This configuration contains the C&C address and various parameters. The structure of the BackDoor.Farfli.125 is as follows: Next, BackDoor.Farfli.125 verifies the config.copy_to_temp flag. If its value is not 0, the trojan copies the .exe file from which it is running into the %TEMP% directory as a file with the com.exe name pattern and launches it through the ShellExecuteA function. In the analyzed sample, the kfwktt is used for config.name in the file name. BackDoor.Farfli.125 uses the current executable module name as an argument for the command line. After that, the trojan verifies the config.delete_files flag. If its value is not 0, the backdoor tries to read the %TEMP%\install00.tmp file and deletes the file whose name is stored in install00.tmp. Next, it deletes the install00.tmp, thumbs.db, rapi.dll and rapiexe.exe files. BackDoor.Farfli.125 creates a C&C server connection object, initializes the Windows Sockets API, but does not establish the connection itself. Next, using the SetProcessWindowStation function, the trojan associates itself with WinSta0 and binds the thread to the Default desktop though the SetThreadDesktop function. If the backdoor finds a config.start_keylogger flag, it initializes a keylogger. Upon its initialization, the mutex is created. Its name consists of two combined names of the module without a file extension: Next, an event with the name is created. The name for the log file is formed as follows: %TEMP%\.txt. To intercept the keystrokes, the window KBDLoger with the KBDLoger class name is created. With that, the interception is performed, using the RegisterRawInputDevices and GetRawInputData functions. The keylogger log file entries are encrypted with the XOR operation and the 0x62 byte. BackDoor.Farfli.125 tries to read the sck.ini file, which is supposed to contain the configuration for the trojan to operate as a SOCKS proxy server. This configuration contains the port number to which the proxy server binding is performed, as well as the name and the password for the authentication. The backdoor supports the SOCKS4 and SOCKS5 modes with capabilities to authenticate using the name and password and is able to resolve the domain names. The operation in the SOCKS proxy server mode is performed in a separate thread. If the configuration file is missing, the trojan skips the proxy server creation stage. The name of the С&C server is stored in config.srv_addr as a string. Moreover, config.url can store a URL, which the trojan uses to request a new address through the WinHTTP API. In this case, the response comes as a C&C server address string, which can also contain the port number, followed by :. The received address is saved in the %TEMP% \.txt file, where is the identificator of the current thread in the % 08x format. Subsequently, the trojan reads the C&C server address from this file and applies it to its configuration. BackDoor.Farfli.125 establishes a keep-alive connection through the TCP socket and generates the encryption key, using the XOR operation with one byte. Next, it extracts the config.password string from the configuration and forms a key in the size of 1 byte from it, using the following algorithm: The config.password string in the analyzed sample is empty, so the data sent to the C&C server remains unencrypted. BackDoor.Farfli.125 collects the following information about the system: After the structure is formed, it is encrypted with a one-byte XOR operation if there is a key and sent to the C&C server. If sending has failed, the thread goes to sleep for config.timeout milliseconds and tries to send the packet again. This routine is repeated until the structure is successfully sent. If sending was successful, BackDoor.Farfli.125 receives a block, consisting of two DWORD in return. The first DWORD is the command ID, while the second DWORD is used in the reply to the command the trojan sends to the C&C server.When responding to each command, the backdoor first verifies the packet with the sysinfo data, where the id field holds the ID of the received command, and the cfg_dword field represents the second DWORD received with this command. There are two groups of commands BackDoor.Farfli.125 works with: