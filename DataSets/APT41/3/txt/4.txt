Cyberespionage has become a more prevalent threat in today’s security landscape, putting private enterprises and public agencies alike at risk of major upsets to their operations. This research paper covers the technical details of a new cyberespionage campaign that we believe can be traced back to the notorious advanced persistent threat (APT) group Earth Baku. In this campaign, Earth Baku’s attacks have been leveled against companies in various countries in the Indo-Pacific region. Trend Micro has previously covered the various methodologies employed by this APT group, which also operates under the alias APT41. Its exploits have been well documented; the group has garnered a reputation for its use of advanced, self-developed tools.1 In fact, Earth Baku has been associated with a slew of cybercrimes such as watering hole attacks2 and spear phishing attacks.3 Its previous targets include companies in the pharmaceutical and telecommunications industries. Earth Baku has yet again updated its arsenal, as evidenced by the latest additions of two shellcode loaders, which we have named StealthVector and StealthMutant, and a modular Windows backdoor, which we have dubbed ScrambleCross. Our in-depth analysis of these newfound malware tools revealed that they have easily customizable features and are distributed through different attack vectors, making it convenient for malicious actors to tailor them to specific victims. This report aims to shed light on the sophisticated toolset involved in this new campaign, although Earth Baku’s motives behind the development of the shellcode loaders and backdoor are not entirely clear. While these have been probably used as part of statebacked attacks to collect competitive intelligence, the inner workings of Earth Baku itself remain unknown. It is likely that the group is composed of threat actors who collaborate by sharing tools with diverse attack infrastructures,4 but their use of the new shellcode loaders and backdoor suggests that they have recruited members with specific areas of expertise. Late last year, we discovered a new shellcode loader designed to execute an arbitrary shellcode with a stealth mode feature. Since then, we have found multiple variants of this loader, which we have named StealthVector, and, in addition, a shellcode loader written in C#, which we have named StealthMutant. These shellcode loaders have two different payloads: the Cobalt Strike beacon and a newly found modular backdoor, which we have dubbed ScrambleCross. Based on their indicators, we have concluded that the threat actors behind this campaign are linked to Earth Baku, an APT group that also goes by the name APT41. Earth Baku, a cyberespionage and cybercriminal group, was charged by the US Department of Justice in August 2020 with computer intrusion offenses related to data theft, ransomware, and cryptocurrency mining attacks.5 Earth Baku’s new campaign, which has been active since at least July 2020, is related to a previous one reported by Positive Technologies6 and FireEye,7 which had used a different shellcode loader, which we had named LavagokLdr, as shown in Figure 1. However, since the group has fully updated its toolset, we recognize this attack as an entirely new campaign. This campaign affects some Indo-Pacific countries, including India, Indonesia, Malaysia, the Philippines, Taiwan, and Vietnam, as illustrated in Figure 2. It targets both enterprises and government entities, including organizations in the airline, computer hardware, automotive, infrastructure, publishing, media, and IT industries. From a geopolitical point of view, many of the countries affected by this recent campaign overlap with those reported in the aforementioned indictment of Earth Baku by the US.Upon studying one of the incident responses from the campaign, we found that Earth Baku performed an SQL injection attack on the victim’s web application to gain a foothold in the network, as depicted in Figure 3.Based on the Visual Basic Script (VBS) scripts used in this attack (Figure 4), we believe that the actors used sqlmap, a Python-based SQL penetration testing tool, to upload a malicious file (Figure 5).This dropper decodes a specified Base64-encoded file, and then drops it in a specified file path. In such an attack, the malware creates install.bat, which installs StealthVector as a Windows service (Figure 6).Another method involves a China Chopper web shell that is uploaded to Microsoft Exchange Server by exploiting the ProxyLogon vulnerability CVE-2021-26855.9 We also detected StealthVector on Microsoft Exchange Server, from which we inferred that Earth Baku likely deployed China Chopper using the ProxyLogon exploit, and then uploaded StealthVector using a web shell (Figure 7). This was not the first time that Earth Baku had capitalized on the ProxyLogon exploit in its operations, as this was also reported by ESET in March 2021.10 We believe that the group’s usage of this exploit is likely to continue unless enterprises address this flaw by updating their systems with the released patch.Upon further investigation on VirusTotal, we discovered that it is possible that the same threat actors have attempted to distribute StealthVector through LNK (link) files sent as email attachments (Figure 8).The LNK file renames CertUtil.exe, a legitimate Microsoft command-line tool, and uses the renamed tool to download both a decoy document and StealthVector (Figure 9). However, we have never seen this type of infection vector in the wild.StealthMutant, for its part, is executed using a different mechanism. Although we are still not certain how an attacker gains access to a system, we have discovered that StealthMutant is executed by InstallUtil.exe through a scheduled task, as illustrated in Figure 10. InstallUtil.exe is a legitimate installer application under Microsoft’s .NET Framework, but it is also known as a living-off-the-land binary (LOLBin) that is used in the proxy execution of .NET Framework programs. In a scheduled task, InstallUtil.exe is registered to run StealthMutant, as demonstrated in Figure 11.StealthMutant is an evasive shellcode loader written in C# that has been in use since at least July 2020. It reads a file that is encrypted by AES-256-ECB, decrypts the file in memory, injects its malicious payload into a remote process, and then executes it. We have observed that its payload has been either the Cobalt Strike beacon or the ScrambleCross backdoor. Most of the StealthMutant samples we have come across are obfuscated by ConfuserEx, an open-source obfuscator for .NET Framework applications. After deobfuscating these samples, we have observed raw namespaces and classes that describe their purpose (Figure 12).All the strings in StealthMutant are encrypted with the encryption algorithm AES-256-ECB and are decrypted on the spot, as shown in Figure 13. The decrypted strings are as follows：The main purpose of StealthMutant is to execute the second stage of the shellcode under stealth mode. To this end, StealthMutant patches the EtwEventWrite function’s API to disable Event Tracing for Windows (ETW), making it invisible to Windows’ built-in logging system. StealthMutant appears to support both 32-bit and 64-bit architectures. In the DoPatch method, StealthMutant determines the architecture dynamically, as demonstrated in Figure 14. If it is running on a 32-bit operating system, StealthMutant patches the system with “C2 14 00 (ret 0x14)”, whereas it patches a 64-bit system with “48 31 C0 C3 (xor rax, rax; ret)”. The file names of the encrypted payload are hard-coded, but these differ with each StealthMutant sample. The file name string is also encrypted using AES-256-ECB. If the target encrypted file exists in a current running directory, StealthMutant reads and decrypts it in memory. Most of the StealthMutant samples use AES-256-ECB for decryption (Figure 15), but the earlier versions of the malware used XOR for decryption (Figure 16). However, we have not spotted these previous iterations of StealthMutant since July 2020.The StealthMutant variants that use AES-256-ECB and XOR share the same decryption steps. The StealthMutant samples that use AES have an encrypted file containing junk bytes, the signature, the seed for the key, the seed for the IV, and the encrypted payload body. The sizes of the junk bytes, the seed for the key, and the seed for the IV vary among the samples. The decryption algorithm of one such StealthMutant sample (Figure 17), which has a junk bytes size of 128, a key seed size of 12, and an IV seed size of 12, is as follows: After the decryption of its payload, StealthMutant executes this shellcode payload in a remote process by using the process hollowing technique. As shown in Figure 18, StealthMutant performs process hollowing through the following steps:This technique is widely used as a red-team tool in C#. Based on its code, we assume that the author of StealthMutant possibly reused an open-source process hollowing implementation from GitHub.In October 2020, we discovered StealthVector, an evasive shellcode loader written in C/C++. This malware implements various evasion techniques and is still actively being developed. We have observed that its payload is either the Cobalt Strike beacon or the malware ScrambleCross. (The Japanese security service company LAC previously published a blog post discussing the Cobalt Strike beacon.12) StealthVector is designed to execute the second stage of the payload in stealth mode. This means that its evasive techniques can be enabled and disabled by its embedded configuration. Because of this, malicious actors can easily customize this loader for their targets. The configuration of StealthVector (Figure 19) is embedded in its data section with ChaCha20 encryption, which is decrypted upon initialization (Figure 20). This ChaCha20 routine notably uses a fixed custom value of 0x13 for the initial counter (Figure 21).According to RFC7539, the Internet Engineering Task Force (IETF) specification for the ChaCha20 stream cipher and the Poly1305 authenticator,13 the ChaCha20 algorithm uses a 32-bit initial counter. This counter can be any number but is usually 0 or 1. As far as we have observed, StealthVector always uses 0x13 for its initial counter, which is an uncommon practice. This makes it difficult to decrypt the malware’s configuration using common methods such as the Python library pycryptodome, which does not support custom initial counters. The decrypted configuration data is copied onto a newly allocated buffer, which determines its behavior. There are two types of configurations found in the wild. One is for a local shellcode runner, which has a size of 0x38. This type of configuration has fields for checksum, flags for context awareness, flags for evasive features, and information for the payload (Figure 22 and Figure 23).The other is for a remote shellcode injector, which has a size of 0x44. This type of configuration has fields for checksum, flags for context awareness, flags for evasive features, information for injection, and information for the payload (Figure 24 and Figure 25). StealthVector has various configurable features that enable malicious actors to easily modify its behavior. We believe this design is meant to keep malware development simple, as the actors will not need to change its source code in order to implement these features. We discuss these features in the succeeding subsections.StealthVector can disable ETW to cover its tracks, as shown in Figure 26.A common feature of other malware, such as mutual exclusion object (mutex) checking or username checking for context awareness, can also be configured into StealthVector, as shown in Figure 27.StealthVector decrypts and executes its payload in memory, but it can also be configured to load its encrypted payload in a specific location. Some variants embed the payload in its binary, while others load it to another file in the same directory, whose file name is specified in the malware’s configuration (Figure 28). The decryption logic is the same for all variants of StealthVector: It reads the specific size of data from a specific offset. The values for the offset and the size of the encrypted payload are already defined in the malware’s configuration. Afterward, the payload will be decrypted by ChaCha20. This same routine is used in decrypting StealthVector’s configuration, but the nonce for its payload is already defined in the configuration (Figure 29).StealthVector can also uninstall itself based on its configuration, as shown in Figure 30.StealthVector implements various shellcode execution techniques. We discuss these techniques in the succeeding subsections.The simplest way for StealthVector to execute its shellcode payload is by using the CreateThread function, as shown in Figure 31.Some variants of StealthVector implement an evasive technique called module stomping, which is designed to bypass the detection of reflective loading. Module stomping is well known because Cobalt Strike has implemented this feature in its version 3.11.14 In the case of StealthVector, however, the injected payload is a shellcode instead of a dynamic link library (DLL). To perform this technique, StealthVector looks for a legitimate DLL that has sufficient space for its payload, “(payload_size + 2048)”, as shown in Figure 32. Once it finds one that meets its space requirement, StealthVector loads that DLL using the LoadLibraryExW function, with the flag DONT_RESOLVE_DLL_REFERENCES. As shown in Figure 33, when this flag is enabled, the system does not call the DllMain of the target DLL upon loading.Once it loads the target DLL, StealthVector changes the protection settings of the DLL using read, write, and execute (RWX) permissions. It then copies its payload onto the legitimate DLL and executes the payload through the CreateThread function, as illustrated in Figure 34.As shown in Figure 35, some variants of StealthVector run their shellcode by bypassing Microsoft’s Control Flow Guard (CFG), an exploit mitigation technology. CFG makes it difficult for malware to run code on Windows operating systems by restricting indirect calls to an unapproved address. In this case, StealthVector executes its shellcode using CreateThread, which checks the target address. In order to sidestep attempts to verify its indirect call, StealthVector will then patch the LdrpHandleInvalidUserCallTarget API in ntdll.dll with “48 FF E0 CC 90 (jmp rax; int3; nop)”, as shown in Figure 36. LdrpHandleInvalidUserCallTarget is called when CFG, through the LdrpValidateUserCallTarget function, determines that the target address is invalid. StealthVector can patch this API without crashing the application.Some variants of StealthVector can also inject their shellcode payload into a remote process using phantom DLL hollowing, a technique that is a combination of process hollowing and module stomping (Figure 37). To do this, StealthVector spawns a new process, which is specified in its configuration, in suspended mode. StealthVector uses the NtCreateSection and ZwMapViewOfSection APIs to load a legitimate DLL into this newly created process. The logic of finding its target DLL is the same as that in module stomping: It checks if the code section, or (.text section size), is large enough. Afterward, it overwrites the code section of the loaded DLL with its own payload and executes it in the DLL’s memory space. It then patches the entry point of the legitimate process in order to modify the shellcode’s execution flow to this entry point in the DLL. Using this method, malicious actors can hide StealthVector’s payload within the memory space of an image, which often goes unnoticed by common memory scan engines, and execute it like a normal module. Our analysis has revealed that StealthMutant and StealthVector can contain two different payloads. One is the Cobalt Strike beacon and the other is the newly found malware ScrambleCross.Among most of the samples we have come across, there are two types of Cobalt Strike beacons: a hybrid HTTP DNS (Domain Name System) and HTTPS. Interestingly, all the Cobalt Strike beacons in memory are in a Portable Executable (PE) file format with a characteristic header, as shown in Figure 38. While it appears as a valid MZ header, it can also be executed as machine code.This assembly, much like a PE header, calculates the address of a specific function, which serves as the entry point for the reflective loader to dynamically initialize and execute a DLL. It should also be noted that some of the samples have PE files with broken headers, although they still operate in the same way (Figure 39).The Cobalt Strike beacons in the samples we have uncovered bear similarities to those used in attacks carried out by the Chimera APT group, as reported by Cycraft.15 However, it remains uncertain whether this campaign can definitively be linked to Chimera, as many similar Cobalt Strike beacons and Meterpreter shellcodes can also be found on VirusTotal (Figure 40).The Cobalt Strike beacon found in the StealthMutant and StealthVector samples has two types of watermarks. One is “305419896”, which is that of a cracked version, and is widely used by a variety of other malicious actors, according to research conducted by VMware Carbon Black.16 The other watermark is “426352781”, which has been in use since at least May 2021 but has never been attributed to malicious actors before. During our analysis, we found a never-before-seen shellcode as a payload of StealthMutant and StealthVector. Upon closer study, we learned that this payload uses similar techniques to those of the Crosswalk backdoor. A modularized shellcode-based backdoor that is known to be used by Earth Baku, Crosswalk can execute additional shellcodes on memory as a plug-in. According to an indictment by the US Department of Justice,17 Crosswalk was also used by members of Chengdu 404 Network Technology, a network security business. The similarities between Crosswalk and ScrambleCross indicate that the actual entity behind this campaign could be or is linked to members of Chengdu 404 Network Technology. Following our analysis, we have concluded that this unknown payload is a new version, or rather a fully refactored version, of Crosswalk. It still has many of the same capabilities as Crosswalk, but these are implemented differently. Considering this, we have named this new backdoor ScrambleCross to distinguish it from its predecessor. ScrambleCross shares the following features with Crosswalk:Crosswalk’s capabilities have been documented at length by the likes of Positive Technologies, ZScaler,18 and VMware Carbon Black.19 But there are some key differences between this backdoor and ScrambleCross. Much like Crosswalk, ScrambleCross also embeds encrypted code in itself, but it uses a slightly different encryption algorithm to do so. To decode its functions and global values, including imports or strings, ScrambleCross uses a 16-byte XOR, as shown in Figure 41. However, for its network configuration, ScrambleCross uses ChaCha20 for decryption instead of XOR (Figure 42). The encrypted network configuration is embedded at offset 0x1028 from the top of the configuration. Like StealthVector, ScrambleCross uses a fixed value of 0xB for its initial counter. The ChaCha20 routine shown in Figure 43 is used for encryption and decryption.With regard to its command-and-control (C&C) server communication, Crosswalk supports TCP (Transmission Control Protocol) and HTTP for application layer protocols, and uses AES-128 for transport layer encryption. ScrambleCross similarly supports TCP, HTTP, and HTTPS for application layer protocols, but it instead uses ChaCha20 and a custom message structure for transport layer encryption. Regardless of whether TCP or HTTP protocols are used, both the client request and the C&C server response have the same message structure. The client request data is compiled in the following nine steps, as illustrated in Figure 44. On the other hand, after deconstructing the server response data, we found that it is compiled in reverse order. ScrambleCross, like Crosswalk, also receives backdoor commands from its C&C server, as shown in Figure 45, but these are very different from those for Crosswalk. In the case of ScrambleCross, the purpose of its backdoor commands is to receive plug-ins from the C&C server and to manipulate these plug-ins, as indicated in Table 1. However, since a backdoor command’s capacity for manipulating plug-ins depends on the specific plug-in it receives, and we have been unable to retrieve any plug-ins from the server, we have yet to determine the full extent of the commands’ plug-in manipulation functions.Because ScrambleCross supports HTTPS, some variants of this backdoor abuse Cloudflare Workers, a computing platform, to obscure their C&C server activity. Cloudflare Workers can prove to be a powerful and accessible tool for malicious actors for the following reasons: During an incident response, we found the installer script for StealthVector called install.bat (Figure 46). This is the same batch file used in a previous cyberespionage campaign carried out by APT41, according to the aforementioned FireEye report (Figure 47). We have observed that Storesyncsvc.dll, the DLL version used by StealthVector, has an entry point for service (Figure 48) that resembles the one mentioned in FireEye’s report (Figure 49). There are also similar procedures for loading the necessary APIs between the Storesyncsvc.dll versions of the StealthVector sample (Figure 50) and the one from the FireEye report (Figure 51). Crosswalk and ScrambleCross implement similar techniques. Both pieces of malware decode their main functions and strings with XOR, after which they check the signature of the decoded section, as shown in Figure 52 and Figure 53. The discovery of these new pieces of malware demonstrates that Earth Baku consists of members with varied skill sets. The group’s use of the StealthMutant and StealthVector loaders indicates that among their ranks is at least one member who is familiar with tools and techniques used by red teams. Likewise, the group’s use of the ScrambleCross backdoor points to at least one member who likely has a deep knowledge of low-level programming and complex software development. Evidence of members with these collective skills obscures the true purpose behind this new campaign. Even though Earth Baku engaged in ransomware attacks in early 2020,20 we have not observed the use of ransomware in this new campaign. Instead, as a report by Group-IB suggests,21 this latest campaign by Earth Baku may be focused on cyberespionage. It is our hope that this report will encourage other security researchers to publish further research about this threat actor group and its activities. Here are several measures that end users and organizations can take to defend their networks and systems against cyberespionage tactics and minimize the risk of compromise Enterprises and government agencies can benefit from advanced Trend Micro solutions that can proactively keep IT environments protected from a wide range of cybersecurity threats. The Trend Micro™ XDR service effectively protects connected emails, endpoints, servers, cloud workloads, and networks.22 It uses powerful AI and expert security analytics to correlate data, and deliver fewer yet higher-fidelity alerts for early threat detection. In a single console, it provides a broader perspective of enterprise systems while at the same time giving a more focused and optimized set of alerts. This allows IT security teams to have better context for identifying threats more quickly and therefore to understand and remediate impact much more effectively. The Trend Micro™ Managed XDR service, meanwhile, provides expert threat monitoring, correlation, and analysis from skilled and seasoned managed detection and response analysts.23 Managed XDR is a flexible, 24/7 service that allows organizations to have a single source of detection, analysis, and response. Analyst expertise is enhanced by Trend Micro solutions that are optimized by AI and enriched by global threat intelligence. The Managed XDR service allows organizations to expand with the cloud without sacrificing security or overburdening IT teams.