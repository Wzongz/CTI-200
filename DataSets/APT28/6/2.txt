The Sednit group — also known as APT28, Fancy Bear and Sofacy — is a group of attackers  operating since 2004 if not earlier and whose main objective is to steal confidential information  from specific targets. This is the third part of our whitepaper “En Route with Sednit”, which covers the Sednit group  activities since 2014. Here, we describe a special downloader named Downdelph. The key points described in this third installment are the following: The Sednit group — variously also known as APT28, Fancy Bear, Sofacy, Pawn Storm, STRONTIUM  and Tsar Team — is a group of attackers operating since 2004 if not earlier, whose main objective  is to steal confidential information from specific targets. Over the past two years, this group’s activity  has increased significantly, with numerous attacks against government departments and embassies  all over the world. Among their most notable presumed targets are the American Democratic National Committee [1],  the German parliament [2] and the French television network TV5Monde [3]. Moreover, the Sednit  group has a special interest in Eastern Europe, where it regularly targets individuals and organizations  involved in geopolitics. One of the striking characteristics of the Sednit group is its ability to come up with brand-new 0-day [4] vulnerabilities regularly. In 2015, the group exploited no fewer than six 0-day vulnerabilities, as shown  in Figure 1. This high number of 0-day exploits suggests significant resources available to the Sednit group,  either because the group members have the skills and time to find and weaponize these vulnerabilities,  or because they have the budget to purchase the exploits. Also, over the years the Sednit group has developed a large software ecosystem to perform its espionage  activities. The diversity of this ecosystem is quite remarkable; it includes dozens of custom programs,  with many of them being technically advanced, like the Xagent and Sedreco modular backdoors  (described in the second part of this whitepaper), or the Downdelph bootkit and rootkit (described  in the third part of this whitepaper). We present the results of ESET’s two-year pursuit of the Sednit group, during which we uncovered  and analyzed many of their operations. We split our publication into three independent parts: Figure 2 shows the main components that the Sednit group has used over the last two years,  with their interrelationships. It should not be considered as a complete representation of their arsenal,  which also includes numerous small, custom tools. We divide Sednit’s software into three categories: the first-stage software serves for reconnaissance  of a newly compromised host, then comes the second-stage software intended to spy on machines  deemed interesting, while the pivot software finally allows the operators to reach other computers. In this third part, we describe the first-stage software named Downdelph, outlined in Figure 2. This software was deployed only seven times by the Sednit operators, according to our telemetry  data. Interestingly, some of these deployments were made with advanced persistence methods:  a Windows bootkit and a Windows rootkit. Readers who have already read the first parts of our Sednit trilogy may skip the following sections and go directly to Downdelph’s analysis. One might expect this reference whitepaper to add new information about attribution. A lot has  been said to link the Sednit group to some Russian entities [7], and we do not intend to add anything  to this discussion. Performing attribution in a serious, scientific manner is a hard problem that is out of scope  of ESET’s mission. As security researchers, what we call “the Sednit group” is merely a set of software  and the related network infrastructure, which we can hardly correlate with any specific organization. Nevertheless, our intensive investigation of the Sednit group has allowed us to collect numerous  indicators of the language spoken by its developers and operators, as well as their areas of interest,  as we will explain in this whitepaper. Before entering the core content of this whitepaper, we would like to discuss our publication  strategy. Indeed, as security researchers, two questions we always find difficult to answer when  we write about an espionage group are “when to publish?”, and “how to make our publication useful to those tasked with defending against such attacks?”. There were several detailed reports on the Sednit group published in 2014, like the Operation Pawn  Storm report from Trend Micro [8] and the APT28 report from FireEye [9]. But since then the public  information regarding this group has mainly came in the form of blog posts describing specific  components or attacks. In other words, no public attempts have been made to present  the big picture on the Sednit group since 2014. Meanwhile, the Sednit group’s activity has significantly increased, and its arsenal differs  from those described in previous whitepapers. Therefore, our intention here is to provide a detailed picture of the Sednit group’s activities  over the past two years. Of course, we have only partial visibility into those activities, but we believe  that we possess enough information to draw a representative picture, which should in particular  help defenders to handle Sednit compromises. We tried to follow a few principles in order to make our whitepaper useful to the various types  of readers: We did our best to follow these principles, but there may be cases where we missed our aim.  We encourage readers to provide feedback at threatintel@eset.com, and we will update  the whitepaper accordingly. The dates presented in this timeline refer to when we believe Downdelph was deployed with  a specific persistence method, possibly against several different targets, and are based on ESET’s  LiveGrid® [12] telemetry data. As mentioned in the timeline, we were able to find only seven deployments of Downdelph. Such deployments start with a dropper, which contains Downdelph and some additional binaries,  as depicted in Figure 4. In Cases 3 to 6, the deployed binaries used a User Account Control (UAC) bypass technique, as mentioned  in Figure 4. Two different UAC bypass techniques were employed; the first one relying on a custom  “RedirectEXE” shim database [13], while the second one is based on a DLL load order hijacking of the  Windows executable sysprep.exe, which possesses the property to auto-elevate its privileges [14]. In Case 7, the dropper was deployed through a targeted phishing email. We do not have any evidence  of this deployment method for the other cases. In this particular case, the dropper opens a decoy  document when executed, to reinforce the illusion the email was legitimate. Figure 5 shows this  decoy document, an invitation to a conference organized by the Slovak Foreign Policy Association  in November 2015 regarding Russia-Ukraine relations [15]. Downdelph’s core logic is implemented in one Delphi class, named TMyDownloader by its developers,  and remained the same in all samples we analyzed. Roughly summarized, Downdelph first downloads  a main configuration file, which allows extending the list of C&C servers, and then fetches a payload  from each of these C&C servers. The whole process is pictured in Figure 6, and is detailed thereafter for the most recent Downdelph sample known (Case 7 in Figure 4). First, Downdelph downloads a main configuration file named extended.ini from the initial  C&C server, whose address is hardcoded in the binary. The network request is an HTTP POST with  a URI containing the file name to fetch encoded with a custom algorithm, as pictured in Figure 7. The response from the server is an RC4-encrypted configuration file following the INI format [16],  and composed of a single section named [options], which contains the key-value pairs described  in Table 1. For each known C&C server — the initial one and the additional ones possibly provided  in extended.ini — Downdelph performs three steps leading to the download of a payload. First, it sends a machine ID, which was previously generated from the hard drive serial number. Second, it downloads a configuration file named pinlt.ini describing the payload to fetch  from this particular C&C server (if any). The network request follows a format similar to the one  shown in Figure 7. The possible key-value pairs of the received file are described in Table 2. Finally, if the previous configuration file is non-empty, Downdelph downloads a payload from  this C&C server, and processes it according to the configuration. Once all C&C servers have been contacted, Downdelph sleeps for a certain amount of time (defined  by the Sleep key in its configuration), and then re-starts the whole workflow from the beginning,  including downloading the main configuration file from the initial C&C server. We do not have in-the-wild examples of Downdelph configuration files. Nevertheless, we know  that in a few cases this component eventually downloaded Sedreco and Xagent. In most of the deployments we analyzed, Downdelph was dropped with a companion binary taking  charge of its persistence, as pictured in Figure 4. This section describes the two most interesting  persistence methods employed, respectively with a bootkit and a rootkit, leaving aside the classic  and more common Windows Registry modification methods. Interestingly, we observed Downdelph deployment with a bootkit on two occasions, Cases 1 and 5  in Figure 4. As defined in ESET’s VirusRadar® [17], a bootkit is “A type of rootkit that infects the Master Boot Record or Volume Boot Record (VBR) on a hard disk drive in order to ensure that its code will be run each time the computer boots. [… ]”. In recent years, bootkits have become popular as a way to load unsigned malicious Windows drivers,  which is normally prevented by the OS in 64-bit versions of Windows. But in the present case the bootkit  serves as a stealthy persistence method for the user-mode downloader Downdelph — although  for this purpose an unsigned driver will indeed be loaded, as we will describe later. Persistence through  a bootkit makes detection harder, as its code is executed before the operating system is fully loaded. The bootkit in question has the ability to infect Microsoft Windows versions from Windows XP  to Windows 7, on both 32-bit and 64-bit architectures. To the best of our knowledge the bootkit used  by Downdelph has never been documented, even though it belongs to the well-known category  of bootkits infecting the Master Boot Record (MBR) — first sector of the hard drive — to take control  of the startup process. We will now describe the various components installed on the machine during the infection  by the bootkit, and then how those components cooperate during startup to eventually  execute Downdelph. The bootkit installation process varies depending on the Windows version, and whether  the machine is 32-bit or 64-bit. In all cases the bootkit installer starts by overwriting the hard  drive’s first sectors — a sector being the basic hard drive storage unit, resulting in a new hard drive  layout as shown in Figure 8 and described in the following.First things first: the MBR is overwritten with a custom version, while an encrypted copy  of the original MBR code is stored in the second sector. Starting in the third sector comes the core  bootkit code, encrypted with a simple XOR-based algorithm. This core code will be slightly different  depending on the operating system versions, as the hooks — described later — put in place at startup  will vary. Finally comes an RC4-encrypted Windows driver, which depending on the architecture will  be a 32-bit or 64-bit binary. In order to access the first sectors of the hard drive, the installer employs a technique previously  seen in the infamous TDL4 bootkit [18], whose code is shown in Figure 9.Once this device access is established, the installer simply calls the Windows API function WriteFile to overwrite the hard drive’s first sectors. It should be noted that this method requires administrative  rights on the system. Second, the installer stores a DLL in the newly created Windows Registry key HKLM\SYSTEM\ CurrentControlSet\Control\Lsa\Core Packages. As we will explain later, this binary  is the user mode component of the bootkit. Additionally, Downdelph itself is stored in the same  registry path, but in the key named Impersonation Packages. These two files are stored in Windows’ Registry following a custom-encrypted data format that  is also used for the bootkit code initially contained in the installer. More precisely, the data are  aPLib-compressed [19], then RC4-encrypted, and begin with the following header: Once installed, the bootkit takes control of the machine during the next system startup. The startup  process is detailed in Figure 10 for Windows 7, where only the steps involving the bootkit are shown. Roughly summarized, a bootkit’s objective is to “survive” Windows’ startup and eventually to execute  a payload once the operating system is fully running. Such survival is made difficult by the strong  modifications of the machine state at each step of the startup process (for example by reorganizing  memory or switching the CPU mode). Hence, starting from the initially infected MBR, the bootkit  ensures at each step that it will regain control at the next step, mainly by setting hooks. While the bootkit workflow described in Figure 10 bears some similarities with other known MBR infected bootkits (see “Bootkits: Past, Present & Future” [20] for some examples), there are certain  particularities that we would like to point out: This code receives as an input parameter the memory address of the Windows kernel ntoskrnl. exe, where the bootkit stores some crucial data in unused PE header fields. Using these data,  it first restores the first five bytes of the original ACPI.sys entry-point, and then redirects to bootkit  code stored at physical memory address 0x97C00, mapped in the virtual memory space using the  Windows API MmMapIoSpace [21]. This bootkit code will decrypt and execute the bootkit driver. As this global variable is absent in all Downdelph binaries, we speculate that the bootkit was  originally intended to be used with a different payload, and was repurposed by Sednit’s operators. Moreover, the user-mode component of the bootkit exports two functions named Entry and ep_data. Those two export names are also present in early samples of the infamous BlackEnergy malware [11]. Also, we found several cases of code sharing between the bootkit components and the same  BlackEnergy samples. These hints lead us to speculate that the developers may be related. Another interesting Downdelph persistence method we analyzed relies on a Windows driver,  used during deployments in February 2014. Once loaded at startup as a Windows service, this driver  executes and hides Downdelph, effectively acting as a rootkit [22]. We were able to dig up only four  samples of this rootkit: three 32-bit versions, corresponding to Cases 2, 3 and 4 in Figure 3,  and an additional 64-bit version for which we do not have any context. Roughly summarized, the rootkit hides certain operating system artifacts (files, registry keys, folders)  whose location matches a rule in a set of so-called Hide rules. Those rules are set by the dropper  and stored in the Windows Registry, making the rootkit a flexible tool able to hide any given artifacts. Interestingly, numerous debug messages were left by the developers in the rootkit, which allow  those Hide rules in particular to be clearly seen. For example, here are the rules used with  one sample, as output in debug logs during execution: To summarize, the rootkit is configured to hide Downdelph and itself from the user, and also  to inject Downdelph into explorer.exe. We are now going to describe how those two operations  are implemented.We have identified two different implementations of the concealment mechanism, depending  on the samples. The first one installs hooks in the System Service Descriptor Table (SSDT) [24],  while the second one relies on the Windows filter manager [25]. The SSDT is an internal Windows table containing addresses of core kernel routines, in such  a way that hooking them allows the interception of data received by user mode programs.  This rootkit hooks three SSDT entries, corresponding to the functions ZwSetInformationFile,  ZwQueryDirectoryFile and ZwEnumerateKey. These three functions are called by Windows processes to access files, directories and registry keys  respectively. The logic inserted by the rootkit is pretty simple: if the accessed artifact path matches  one of the Hide rules, then the function returns as if the artifact does not exist on the system.  On the other hand, if the accessed artifact path is not rootkit-protected, the original SSDT function  is executed. For example, the hook code for ZwSetInformationFile to hide files is presented  in Figure 13. With the arrival of 64-bit versions of Windows, the SSDT became protected by Kernel Patch  Protection [26], preventing the insertion of hooks into this table. This probably explains why  a different implementation of the concealment functionality was introduced in the rootkit,  as described below. The Windows filter manager [25] allows registering a driver as a minifilter, so that its code will  be called on certain I/O operations. Such a minifilter driver can register a pre-operation callback  or a post-operation callback on each I/O operation it registers to filter. Minifilter drivers are ordered based on a value called “altitude”: the filter manager executes driver  callbacks registered for an I/O operation in the descending order of altitude. This ordering allows,  for example, prioritizing anti-virus minifilters over data-processing minifilters, in order to detect  malicious files before opening them. In our case, the rootkit driver registers itself as a minifilter of altitude 370030. This altitude  is normally associated with a Windows legacy driver named passThrough.sys [27], which  is an example of a minifilter open-sourced by Microsoft [28]. Thus, the rootkit takes the place  of passThrough.sys in the minifilter stack, and provides callbacks for hiding. The concealment functionality is mainly implemented as a pre-operation callback on the IRP_MJ_ CREATE [29] I/O operation, which corresponds to the creation or opening of files and directories.  The callback code is shown in Figure 14. Regarding hiding registry keys, the developers simply re-used the code of another minifilter  example [30] released by Microsoft for that purpose. As a final note on this rootkit’s concealment mechanisms, we would like to mention that we found  a 64-bit version of the minifilter-based rootkit made to run on Windows 7 (according to its PDB path  […​ ]win7\x64\fsflt.pdb). Loading such unsigned driver is normally prevented on this operating  system, and we do not know if the attackers may have actually loaded it. DLL Injection Once the hiding mechanisms have been put in place, the rootkit injects the DLL whose path is in the  Inject dll rule (Downdelph in our case) into explorer.exe. To do so, it first copies a shellcode  into explorer.exe, which simply calls Windows API LoadLibraryW on Downdelph path. To execute the shellcode, the rootkit then queues a kernel asynchronous procedure call (APC) [31],  a little-known code injection technique. The code responsible for the injection is pictured in Figure 15. Deploying a component as simple as Downdelph with a bootkit or a rootkit may seem excessive.  But given the apparent rarity of Downdelph deployments over the last two years, we are inclined  to speculate this is a deliberate strategy. By rarely deploying it, Sednit operators apparently kept it out of the hands of malware researchers  for almost two years, which, combined with advanced persistence methods, ensured that they were  able to maintain the monitoring of selected targets over the long term. Still, we are certainly missing parts of the picture concerning Downdelph, and we hope this report  will encourage other researchers to contribute further pieces to the puzzle.