While continuing to monitor activity of the OceanLotus APT Group, BlackBerry Cylance researchers uncovered a novel payload loader that utilizes steganography to read an encrypted payload concealed within a .png image file. The steganography algorithm appears to be bespoke and utilizes a least significant bit approach to minimize visual differences when compared with the original image to prevent analysis by discovery tools. Once decoded, decrypted, and executed, an obfuscated loader will load one of the APT32 backdoors. Thus far, BlackBerry Cylance has observed two backdoors being used in combination with the steganography loader – a version of Denes backdoor (bearing similarities to the one described by ESET), and an updated version of Remy backdoor. However, this can be easily modified by the threat actor to deliver other malicious payloads. The complexity of the shellcode and loaders shows the group continues to invest heavily in development of bespoke tooling. This white paper describes the steganography algorithm used in two distinct loader variants and looks at the launcher of the backdoor that was encoded in one of the .png cover images. This particular OceanLotus malware loader attempts to imitate McAfee’s McVsoCfg DLL and expects to be side-loaded by the legitimate “On Demand Scanner” executable. It arrives together with an encrypted payload stored in a separate .png image file. The .png cover file is actually a valid image file that is not malicious on its own. The payload is encoded inside this image with the use of a technique called steganography, which utilizes the least significant bits of each pixel’s color code to store hidden information, without making overtly visible changes to the picture itself. The encoded payload is additionally encrypted with AES128 and further obfuscated with XOR in an attempt to fool steganography detection tools.The malicious DLL exports the same function names as the original mcvsocfg.dll library. All exports contain the exact same code which will decrypt the payload, inject it into memory, and execute it: The payload is encoded inside a separate .png file using a technique called steganography. On top of that, the decoded payload is also encrypted with AES-128 and finally obfuscated with XOR 0x3B. It’s worth noting that the XOR key is not hardcoded, but instead is read from the first byte of the C:\Windows\system.ini file:One of the payloads we encountered was encoded inside an image of Kaito Kuroba1 , the gentleman thief character from a popular Japanese manga series：The size of the payload is encoded within the first four pixels of the image. After obtaining the size, the malware will allocate an appropriate memory buffer and proceed to decode the remaining payload byte by byte：The payload is encoded in the same way as the size – each byte of the payload is computed from the ARGB color codes of each subsequent pixel in the image:In case the payload is bigger than the image used to store it, the remaining payload bytes are simply attached to the image after its IEND marker, and read directly from the file:The pixel encoding algorithm is fairly straightforward and aims to minimize visual differences when compared to the original image by only modifying the least significant bits of the red, green, and blue color byte values. The alpha channel byte remains unchanged. To encode a byte of the payload, the first three bits (0-2) are stored in the red color, the next three bits (3-5) are stored in the green color, and the final two bits (6-7) are stored in the blue color. Decoding is a simple inverse operation:After decoding the .png image, the loader then proceeds to initialize the key and IV used to perform AES decryption of the encrypted payload. Both values are supplied from an array of 256 pseudo-random bytes hardcoded in the binary’s .rdata section. The first two bytes of that array specify the relative offsets to the key and IV respectively:We were able to correlate most of the disassembly to the corresponding functions from the Crypto++ github source, and it doesn’t appear that the malware authors have modified much of the original code. A SimpleKeyringInterface class is used to initialize the key, while the IV is passed to the SetCipherWithIV function:While this loader differs somewhat in general implementation, the payload extraction routine seems to be the same as in the previous variant. The main differences are:We came across multiple variations of this DLL containing different parent process names, possibly targeted specifically to the victim’s environment. Some of these names include processes related to security software:The final payload comes in a form of a launcher DLL that contains an encrypted backdoor in its .rdata section and a plain-text configuration in its resources. The resources also store one or more C2 communication modules. The backdoor DLL and the C2 communication DLLs are heavily obfuscated using high quantities of junk code, which significantly inflates their size and makes both static analysis and debugging more difficult. In addition to Denes and Remy backdoors, at least two different communication modules were observed with different versions of this launcher – DNSProvider and HTTPProv.The launcher binary, which contains the final backdoor, is RC4 encrypted and wrapped in a layer of obfuscated shellcode. We can see the familiar DOS stub in plain text, but the rest of the header and binary body are encrypted: