The OceanLotus group, also known as APT32 and APT-C-00, is infamous for its campaigns targeting the eastern part of Asia. A great deal of research about this group was published last year, including papers such as those from CyberReason, a lengthy global view from FireEye and the watering-hole explanation from Volexity. We see that this group keeps updating their backdoors, infrastructure, and infection vectors. OceanLotus continues its activity particularly targeting company and government networks in East-Asian countries. A few months ago, we discovered and analyzed one of their latest backdoors. Several tricks are being used to convince the user to execute the backdoor, to slow down its analysis and to avoid detection. These techniques will be discussed in detail in this blog post.Various methods are used to trick potential victims into running the malicious dropper. Our telemetry reveals that East-Asian countries such as Vietnam, the Philippines, Laos and Cambodia, are the most targeted.Several fake installers, claiming to be installers or updates for popular software were seen in watering hole campaigns. A good example of such an installer is the repackaged Firefox installer described by 360 Labs on Freebuf (Chinese language). Another sample we saw had the name RobototFontUpdate.exe. It was also likely to have been distributed via compromised websites, but we do not yet have enough evidence to confirm this. All the files described here, whether they were sent in an email or downloaded while visiting a compromised site, deliver the same (functionally equivalent) backdoor component. For the purpose of this article we will dissect the RobototFontUpdate.exe sample and show how it manages to execute its malicious payload on a system. The whole process of installation and execution relies heavily on multiple layers of obfuscation such as decryption of payloads, PE reconstruction and loading shellcode, and side-loading techniques. The last technique was previously described in a previous ESET research article about Korplug.The attack is split in two parts: the dropper and backdoor launcher. Each step of each part of the process will be explained in detail in its respective section. The following two diagrams briefly summarize the general flow of execution of the malware. The dropper part has the following flow of execution:Almost all of these components are obfuscated. The obfuscation is based on pairs of complementary conditional jump instructions. Every form is used: JZ/JNZ, JP/JNP, JO/JNO, etc, each pair jumping to the same target. The sequence is interleaved with junk code, which makes use of the stack pointer, but does not change the conditional flag’s value. This means it will always end up in the same branch. This causes problems during decompilation due to the use of positive stack pointer values.Moreover, some basic blocks push one address on the stack, then end with a JMP/CALL while other basic blocks push two addresses then end with a RET instruction. The second push is the function to call and the first one is the address of the next basic block to jump to. This creates basic blocks with no parents.The junk code is pretty easy to spot and once the scheme is known, it can be ignored when analysing the samples.Over the past few months, a number of decoy documents have been used. One of them was a fake TrueType font updater for the Roboto Slab regular font. This choice of font seems a bit odd since it does not support a lot of East-Asian languages.When executed, this binary decrypts its resource (XOR with a 128-byte, hardcoded key) and decompresses the decrypted data (LZMA). The legitimate RobotoSlab-Regular.ttf (SHA1:912895e6bb9e05af3a1e58a1da417e992a71a324) file is written into the %temp% folder and run via Win32 API function ShellExecute.The shellcode decrypted from the resource is executed. After its execution, the fake font updater drops another application whose sole purpose is to delete the dropper. This “eraser” application is dropped as %temp%\[0-9].tmp.exe.The shellcode is a custom PE loader. It recreates an executable in memory: it decrypts all the sections and computes the necessary relocations and other offsets. The shellcode retrieves three Windows API functions: VirtualAlloc, RtlMoveMemory and RtlZeroMemory. The RtlZeroMemory function is heavily used to zero-out fields in the PE header. Relying on automatic memory dumping will not work since the MZ/PE headers are broken. The shellcode calls the entry-point function of the decrypted PE and then the DLLEntry export function.This executable decrypts its resource using the AES algorithm with CBC mode via the Windows API. The size of the hardcoded key is 256 bits. After decryption, the data are decompressed (LZMA algorithm). If the process is running with administrator privileges, then the malware achieves persistence by creating a service, else the classic Windows “Run” registry key is used (HKCU\SOFTWARE\Microsoft\ Windows\CurrentVersion\Run;DeviceAssociationService;rastlsc.exe). If the dropper is executed with administrator privileges, then it tries to write the following files in the C:\Program Files\Symantec\Symantec Endpoint Protection\12.1.671.4971.104a\ DeviceAssociationService\ folder else it writes them in the %APPDATA%\Symantec\Symantec Endpoint Protection\12.1.671.4971.104a\DeviceAssociationService\ folder:These paths are used by various Symantec products. After achieving persistence and dropping the executable, the legitimate Symantec executable, rastlsc.exe, is executed using CreateProcessW. We’ve also seen another version ({BB7BDEC9-B59D-492E-A4AF-4C7B1C9E646B}.dll), which executes rastlsc.exe with the parameter krv. Its meaning is discussed below. The OceanLotus group uses an old and publicly known technique on one of the Symantec product’s executable files. The trick, here, is to take advantage of the library loading process of a legitimate and signed executable by writing a malicious library inside the same folder. This way it will make malicious behaviors look legitimate because these actions are made by the trusted executable process. As mentioned earlier, the legitimate executable rastlsc.exe is dropped and executed. This executable imports the rastls.dll file, which in this case contains the malicious payload.Side loading was also observed using other legitimate, signed executables including mcoemcpy.exe from McAfee, which loads McUtil.dll. This technique has also been used by PlugX before. This also got the attention of the Vietnam CERT (Vietnamese language).The internal name of this dll is {7032F494-0562-4422-9C39-14230E095C52}.dll but we’ve seen other versions like {5248F13C-85F0-42DF-860D-1723EEAA4F90}.dll. All exported functions lead to the execution of the same function. This export tries to read the SyLog.bin file located inside the same folder. Other versions tried to open the file OUTLFLTR.DAT. If that file exists, it is decrypted using AES in CBC mode with a hardcoded, 256-bit key and then decompressed (LZMA compression). The McUtil.dll variant uses a different technique. At first glance, it looks as if like the main function does nothing malicious, but in fact it replaces the .text section of the legitimate mcoemcpy.exe, a side-loaded binary. It generates shellcode whose purpose is to call the function reading the encrypted stage-two shellcode in the mcscentr.adf file. The following pseudocode is used to create the shellcode: The result is the following assembly listing: The shellcode decrypts and loads the library {E1E4CBED-5690-4749-819D-24FB660DF55F}.dll. The library retrieves its resource and tries to start the service “DeviceAssociationService”. The decrypted data also contains shellcode. The latter decrypts the final layer: the backdoor. The variant {92BA1818-0119-4F79-874E-E3BF79C355B8}.dll checks whether rastlsc.exe was executed with krv as the first parameter. If so, then a job is created and rastlsc.exe is executed again, but without the parameter. The malware first tries to retrieve its resource and decrypt it using RC4. The decrypted resource contains an interesting piece of information, used to configure the backdoor. The format of this configuration is straightforward to reverse. Using Kaitai struct and its structure dumper, the following representation can be displayed:The malware retrieves the first 10 bytes of the username (UTF-16), XORs it with the 3-letter UTF-16 mutex_encoding_str string, and encodes it in hex. The result is used as a mutex name. For instance, for a user whose name starts with abc and the key being vwx, the following mutex will be created: \Sessions\1\BaseNamedObjects\170015001b. The backdoor includes a PE loader that loads the library HTTPProv.dll in memory, calls its entrypoint and then calls the export function named CreateInstance. The backdoor uses a classic TCP communication protocol over port 25123. In order to retrieve the server IP address, the backdoor first creates a particular DNS query. The malware chooses between one of the three domains from the configuration and adds a custom sub-domain generated using two values. The first value is the computer name up to a length of 16 bytes. The second value is the 4-byte version ID. The following Python 2 code implements the encoding algorithm :For instance, if the computer name is random-pc and the version ID is 0x0a841523 then the following domain could be created: niggmhggmeggmkggmfggmdggidggngggmjgg.ijhlokga.dwarduong[.]com The following regular expression could be used to flag a C&C server for this backdoor: [ghijklmnopabcdef]{4-60}\.[ghijklmnopabcdef]{8}\.[a-z]+\.[a-z]+ If an IP address is resolved for this particular domain, then the malware tries to establish a connection on TCP port 25123. Each sample has three different domain names it can use to find its C&C server. All communication is encrypted using RC4 and compressed with LZMA. It is possible to decrypt the traffic because the key is prepended to the packets. The format is: [RC4 key (4 bytes)][encrypted data] Each byte of the key is generated using the rand function. Once the packet is decrypted and decompressed, the data follow the format: [dw:unknown][dw:unknown][dw:command number][dw:size of data][dw:unknown] [dw:data] The first time the client connects to the server, a UUID is returned and used as a session ID. The latter is stored in the registry key as binary data: HKCU\SOFTWARE\Classes\ AppXc52346ec40fb4061ad96be0e6cb7d16a\DefaultIcon As mentioned earlier, the backdoor also contains a library called HTTPprov. This library is an alternative way, as a backup, to communicate with the server as a backup. This DLL sends a POST request over the HTTP protocol to communicate. It also supports HTTPS and the usage of a SOCKS5, SOCKS4a or SOCKS4 proxy. The library is statically linked with libcurl. Once its initialization is done, the following registry key is created to instruct the backdoor to use HTTP in future communication with the C&C server: HKCU\SOFTWARE\Classes\ CLSID{E3517E26-8E93-458D-A6DF-8030BC80528B}. A generic user agent is used: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0). The most distinctive characteristic of this library is the custom URI encoding algorithm. The resource part of the URI is created using the following pseudocode:After receiving its SESSIONID, the backdoor does a fingerprint of the system. The packet is built in this fashion:Once again, OceanLotus shows that the team is active and continues to update its toolset. This also demonstrates its intention to remain hidden by picking its targets, limiting the distribution of their malware and using several different servers to avoid attracting attention to a single domain or IP address. The encryption of the payload, together with the side-loading technique – despite its age – is a good way to stay under the radar, since the malicious activities look like they come from the legitimate application.