The Middle East has been a cyber warfare hotspot for almost a decade now, a theatre for some of the most advanced threats the world has ever witnessed. In between those highly advanced attacks, more and more attackers possessing only a basic set of skills started to pop up – spreading well known RATs, obfuscated with generic publicly-available packers. This report focuses on the CopyKittens, a mid-level group. The CopyKittens attacks are effective and advanced in a few ways:Yet, this group is clearly not made up of dozens of high-end computer and security experts. The CopyKittens assembled major parts of their attack from code snippets carefully picked from public repositories and online forums, hence their nickname. We also named their attack tool "Matryoshka"1 due to the fact that it was written as a multi-stage framework, with each part of it built to integrate its subsequent step. We have had only a partial window to the targets of these semi-sophisticated yet highly effective attacks. Among them were high ranking diplomats at Israel’s Ministry of Foreign Affairs and some well-known Israeli academic researchers specializing in Middle East Studies. Even if we combine this with the fact that attackers goal seemed to be theft of sensitive data, we still lack the ability to clearly identify who is behind this attacks and if it was sponsored by another major actor. In our opinion, this will not be the last time we hear from this group. Their constant striving toward improved performance, the fact that they probably executed successful attacks and the current turmoil in the Middle East region leads us to the conclusion that the CopyKittens will keep striking targets with similar profiles in the near future.CopyKittens has conducted at least three waves of cyber-attacks in the past year. In each of the attacks the infection method was almost identical and included an extraordinary number ofstages used to avoid detection. As with other common threat actors, the group relies on social engineering methods to deceive its targets prior to infection.The attack is initiated by sending an infected document file as an email attachment. In most cases the email subjects have been carefully chosen to match the target’s interests. We were able to retain a copy of an email used to target an Israeli ambassador in a large eastern European country. Some of the emails subjects were: The embedded binary objects in the lure documents contained a trailing “fdp.scr” in their names with a special invisible Unicode character. This character officially described as "Right-To-Left Override" flips the directionality of the string from its position and onward. For example, if we name a file "filename [special flipping char]fdp.scr" it will be displayed as "filename rcs.pdf”. This form of subterfuge has been previously employed by other Middle Eastern threat actors such as “Desert Falcons”, reported by Kaspersky3 and by elements operating in Syria4 . In other cases, the document includes instructions motivating the victim to enable macro code execution. If the trap is successful and the user played his part, the infection stage begins.Unlike most malwares, CopyKittens’ tools are bound to each other. The Matryoshka infection framework is built of three parts:Files with scr extension are just the same as exe executables. Windows screen savers originally used this extension but nowadays medium-level threat actors commonly use it as a way to deceive the average user who might be deterred from an exe file extension. The dropper name always matched the promised content of the spear phishing email. In the latest version of the dropper, the lure pdf is saved to the user’s %TEMP% folder with an “~st” prefix and random number, followed by a “.pdf” extension. Once the file has been successfully saved, the pdf is opened and displayed to the user via ShellExecute API and Open command. This is done to lower the target's suspicions and mask the true functionality of the executable. While the user unsuspectingly reads the document, the following routine runs hidden in the background: The malware first unpacks the “Reflective Loader” component into the memory and signals to its “C2 parents” the attack has been executed by downloading an image file from a remote server. The URL of the remote file is built out of two constant strings which again might suggest some kind of builder to this platform. After signaling to the attackers, the malware calls a specific export function from the Reflective Loader named “_check”. This routine is a copied code from the “Pafish” open source project, led by Alberto Ortega (@a0rtega) 5 who describes it as: “A demonstration tool that employs several techniques to detect sandboxes and analysis environments in the same way as malware families do”. Pafish will enumerate and look for known virtualization and sandbox artifacts and then print results back to the researcher screen.Since the original Pafish code is built to improve security researchers’ ability to discover evasive malware, the CopyKittens group has modified the code logic. Instead of printing the functions’ results back to the user, the code will now assign a static number from 1-27 in the case of an artifact being found, and will return that value to the calling function (the SCR dropper in this case). Upon returning from the “_check” function, the dropper will perform a simple comparison and if an analysis machine has been detected, it will signal the attackers again using almost the same URL as it did before but replacing the name of the “.png” file to the letter “n” concatenated with the number of the artifact found by Pafish. Below is a table demonstrating the artifacts and their corresponding value:During our investigation we were able to identify an example of this behavior in a VirusTotal report on one of the domains used by the attackers: We believe this URL was submitted by a target or other researchers analyzing the malware. After alerting the attackers they have been discovered, the dropper will try to delete the temporary files created by him and terminate activity of the infection process. In the case no analysis machine is found, Reflective Loader will be called again with the “_dec” (possibly abbreviation of the word “decrypt”) and the third stage of the attack will commence. In an attempt to increase stealthiness, the CopyKittens group has decided to use another open source project6 by Stephen Fewer (@stephenfewer). The project implements a remote library injection technique called “Reflective DLL Injection”. Fewer describes the method in his paper7 : “Reflective DLL injection is a library injection technique in which the concept of reflective programming is employed to perform the loading of a library from memory into a host process”. This method enables the RAT library to run on the host machine without a dedicated process and without registration of the library under the loaded modules. The original project was built as a command line utility with the target process identifier provided as an argument. In a real attack scenario, the injected process identifier is obviously unknown to the attacker and a suitable host process should be located at runtime. The CopyKittens group has implemented this routine by using WTSEnumerateProcess API to get a list of current active processes and then trying to get a handle to each process via OpenProces API, avoiding x64 processes.The main part of “Matryoshka” is a remote administration tool library. It is designed to exist in the infected computer memory and is never written to the computer's physical disk itself. When we “dumped” the RAT to the disk, some of the AV tools detect it with the following signatures：Since the library is injected into memory, the imported functions must be resolved in runtime, to solve this problem the CopyKittens group used a method called “Runtime API Address Resolution”10 using the LoadLibrary and GetProcAddress APIs. In order to evade static virus scannersin new version of the RAT, the attackers obfuscated the names of the API functions. They resolve them in runtime using a simple substitute cipher combined with Base64 encoding. The same trick was used in the Reflective Loader component. We retrieved the original functions names as plaintext strings by using a simple Python script. A list of decrypted API strings and the python code can be found in the Appendix and Minerva Labs Research GitHub repository11 . Since the RAT library was built to run from the memory of a host process, it relies on the loader to survive system restart. The first time the RAT runs, it will copy the reflective loader, named “kernel.dll” to one of Windows’ common folders and will create a registry key named {0355F5D0- 467C-30E9-894C-C2FAEF522A13} under “SOFTWARE\Microsoft\Windows\CurrentVersion\Run” with the value of “C:\Windows\System32\rundll32.exe "\%LOCATION%\kernel.dll" _dec” to rerun the injection routine after each boot. In addition, to make sure the RAT always runs (since host process might be closed or crash), the RAT creates a task in the Windows task scheduler named “Microsoft Boost Kernel Optimization” which will re-run the injection routine every 20 minutes. The task scheduler method has also been added to the newest version of the RAT.This makes the RAT unstable as multiple instances may be executed simultaneously on the same host machine causing unexpected behavior. To reduce this risk, the authors have used a global mutex.Once a command is received from the C2 server in the DNS response, the RAT will translate it to a corresponding command. For example, when the C2 sends a DNS response with the IP address 134.170.185.13, the RAT will try and steal outlook passwords.This functionality resembles a method described by SecurityExploded 12 for “Recovering Passwords from Outlook 2002-2013”. We can assume that the group has copied this code as well. In comparing samples from different attack cycles, we can easily see that the attackers have spent time improving their tool, making it more persistent and harder to detect. For example, between the first versions of the RAT and the latest, the group started to resolve more API during runtime, using obfuscated strings. A comparison of the outlook password extraction function from previous and current RAT versions can be seen below.